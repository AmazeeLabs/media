<?php
// $Id$

/**
 * @file
 * Install, update and uninstall functions for the Media module.
 */

/**
 * Implements hook_install().
 */
function media_install() {
  /**
   * DISCLAIMER:
   * Yes I am altering a core table.
   * No I am not on crack.
   * Basically, the problem we're facing is the media "type" which is not the
   * mime type, but is probably computed from it.
   *
   * The file table has no type field.  As a result, we would have to either:
   *
   * 1). Create a media_files table to join them.  This is nice and clean,
   * however it requires keeping the tables in sync, and it also means we have
   * to write our own SQL instead of using BaseEntityController, and that's
   * kinda scary.
   *
   * 2). Make the media type a "computed" field.  Wherein, everytime we loaded
   * a piece of media, we would need to compute its type from the mime-type.
   * This is unacceptable from a performance standpoint and also requires us
   * override the Controller in ways we probably don't want to.
   *
   * I know it's a sin, but I think it is also excusable because:
   *
   * 1). This is hoping to be a core addition, so think of it as a core patch
   * that will eventually go in.
   *
   * 2). It is adding a new field, so it shouldn't cause any conflicts.  If it
   * does that INSERT / SELECT code is badly written and should use complete
   * INSERTS or column names.
   */

  // Alter {file}.type and add it as an index.
  db_add_field('file', 'type', _media_type_field_spec());
  db_add_index('file', 'file_type', array('type'));
}

/**
 *  Implement hook_enable().
 */
function media_enable() {
  // @TODO: Revisit the default types to provide. For instance, PDFs and text.
  // @TODO: We may need to disable the media bundle & field in hook_disable.

  $view_mode_defaults = array(
    'media_preview' => 'styles_file_square_thumbnail',
    //@TODO: We need a real "original" formatter
    'media_original' => 'styles_file_large',
    'media_small'   => 'styles_file_small',
    'media_large'   => 'styles_file_large',
  );

  $types = array();

  // This is the default type which will be used if no other type is found
  $types['default'] = new StdClass();
  $types['default']->machine_name = 'default';
  $types['default']->label = "Other";
  $types['default']->base = TRUE;
  //@todo: I don't like this but we have to do something here.
  $types['default']->view_mode_defaults = $view_mode_defaults;

  $types['default']->weight = 1000;
  // This is the default.
  $types['default']->type_callback_args = array(
    'match_type' => 'any',
    'mimetypes' => array('/.*/'),
  );

  // Add the common media types.
  $types['image'] = new StdClass();
  $types['image']->machine_name = 'image';
  $types['image']->label = "Image";
  $types['image']->base = TRUE;
  $types['image']->view_mode_defaults = $view_mode_defaults;

  $types['image']->type_callback_args =
  array(
    'match_type' => 'all',
    'mimetypes' => array('/^image/'),
    'extensions' => array('jpg', 'jpeg', 'gif', 'png', 'tiff'),
    'streams' => array('public', 'private'),
  );

  $types['audio'] = new StdClass();
  $types['audio']->machine_name = 'audio';
  $types['audio']->label = "Audio";
  $types['audio']->base = TRUE;

  // @todo: these are image specific, needs to change
  $types['audio']->view_mode_defaults = $view_mode_defaults;
  $types['audio']->type_callback_args = array(
    'match_type' => 'all',
    'mimetypes' => array('/^audio/'),
    'extensions' => array('mp3', 'ogg', 'wma'),
    'streams' => array('public', 'private'),
  );

  $types['video'] = new StdClass();
  $types['video']->machine_name = 'video';
  $types['video']->label = "Video";
  $types['video']->base = TRUE;

  // @todo: these are image specific, needs to change
  $types['video']->view_mode_defaults = $view_mode_defaults;

  $types['video']->callbacks = array();
  // This is the default, otherwise could provide
  //$types['video']->type_callback = 'media_default_is_type';
  $types['video']->type_callback_args =
  array(
    'match_type' => 'all',
    'mimetypes' => array('/^video/'),
    'extensions' => array('mov', 'mp4', 'avi'),
    'streams' => array('public', 'private'),
  );

  foreach ($types as $name => $type) {
    media_type_save($type);
  }
}

/**
 *  Define the database {file}.type field.
 */
function _media_type_field_spec() {
  return array(
    'description' => 'Type of file for use in Media Bundles',
    'type' => 'varchar',
    'length' => 50,
    'not null' => FALSE,
  );
}

/**
 * Implement hook_schema().
 */
function media_schema() {
  $schema['media_list_type'] = array(
    'description' => 'Stores the user preference for whether to list as table or images.',
    'fields' => array(
      'uid' => array(
        'description' => 'The {user}.uid of the user.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'type' => array(
        'description' => 'The type of display (table or images).',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
        'default' => '',
      ),
    ),
    'primary key' => array('uid'),
  );

  return $schema;
}

/**
 * Implement hook_schema_alter().
 */
function media_schema_alter(&$schema) {
  // Alter {file}.type.
  $schema['file']['fields']['type'] = _media_type_field_spec();
}

/**
 * Implement hook_uninstall().
 */
function media_uninstall() {
  /**
   * See comment above in media_install.
   */
  db_drop_field('file', 'type');
  $types = node_type_get_types();
  $global = new stdClass;
  $global->fields = field_info_instances();
  $types['global'] = $global;
  foreach ($types as $name => $type) {
    variable_del('media_' . $name . '_override');
    variable_del('media_' . $name . '_enabled');
    if (isset($type->fields)) {
      foreach ((array)$type->fields as $field_name => $field) {
        foreach (media_registration_kinds() as $kind) {
          variable_del('media_' . $node_type . '_' . $field['field_name'] . '_' . $kind);
        }
      }
    }
  }
  variable_del('media_file_extensions');
  variable_del('media_max_filesize');
  variable_del('media_file_progress_image');
  variable_del('media_file_list_size');
  variable_del('media_file_progress_success');
}

/**
 * Create the {media_list_type} table.
 */
function media_update_7000() {
  db_create_table('media_list_type', array(
    'fields' => array(
      'uid' => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'type' => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
    ),
    'primary key' => array('uid'),
  ));
}

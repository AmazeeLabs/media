<?php
// $Id$

/**
 * @file
 * Media API
 *
 * The core Media API.
 * The Media module provides a drop-in replacement for Drupal's Upload,
 * FileField, Embedded Media Field, and other similar forms. It offers an API
 * and hooks available for other modules to implement, allowing for customized
 * file lists, tabs, drawers, and forms to the new Upload form.
 */


 /**
  * @TODO
  *   * we need to remove cruft from earlier implementation strategy
  *   * we need to modify the registration hook
  *   * we need to handle the content browser ajax through drupal FAPI ahah
  *   * we need better UI
  *   * file extesion validation is not working correctly for * option
  *   * files are not currently being attached by the file uri field
  */

/* ***************************************** */
/* CONSTANTS                                 */
/* ***************************************** */

define('MEDIA_RESOURCE_URI_DEFAULT', 'public://');
define('MEDIA_TYPES_DEFAULT', '*');

/* ***************************************** */
/* DRUPAL API FUNCTIONS                      */
/* ***************************************** */

/**
 * Implement hook_menu().
 */
function media_menu() {
  // AJAX formatter. This page is used to create the formatter form
  // when adding a new file, after selecting a file and pressing 'Add'.
  $items['media/js'] = array(
    'page callback'    => 'media_ahah_formatter_load',
    'access arguments' => array('access content'),
  );
  $items['media/metadata/js'] = array(
    'page callback'    => 'media_ahah_metadata_ahah',
    'access arguments' => array('access content'),
  );

  // Handles all the callbacks from the media content browser
  $items['media/browser/dispatch'] = array(
    'page callback'    => 'media_browser_dispatch',
    'access arguments' => array('access content'),
  );

  // Admin settings
  $items['admin/content/media'] = array(
    'title' => 'Media',
    'description' => 'Manage files used on your site.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('media_admin'),
    'access arguments' => array('administer media'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'media.admin.inc',
  );

  $items['admin/content/media/%file/edit'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('media_edit', 3),
    'access arguments' => array('administer media'),
    'type' => MENU_CALLBACK,
    'file' => 'media.admin.inc',
  );

  $items['admin/content/media/add/files'] = array(
    'title' => 'Upload new files',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('media_add_files'),
    'access arguments' => array('administer media'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'media.admin.inc',
    'weight' => -1,
  );
  /*
  $items['admin/content/media/add/folder'] = array(
    'title' => 'Add new folder',
    'page callback' => 'media_add_folder',
    'access arguments' => array('administer media'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'media.admin.inc',
    'weight' => 20,
  );
  */
  $items['admin/content/media/add/external'] = array(
    'title' => 'Add new external source',
    'page callback' => 'media_add_external',
    'access arguments' => array('administer media'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'media.admin.inc',
  );

  // Default settings, for content types that do not have their own.
  $items['admin/config/media/media'] = array(
    'title'            => 'Media settings',
    'description'      => 'Configure Global Media settings, including default content type settings.',
    'file'             => 'media.admin.inc',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('media_settings_global'),
    'access arguments' => array('administer media'),
    'weight'           => 3,
  );

  return $items;
}


/**
 * Implement hook_permission().
 */
function media_permission() {
  return array(
    'administer media' => array(
      'title' => t('Administer media'),
      'description' => t('Add, edit or delete media.'),
    ),
  );
}


/**
 * Implementation of hook_form_alter().
 * @param $form
 * @param $form_state
 * @param $form_id
 */
function media_form_alter(&$form, &$form_state, $form_id) {
  // Load content-type settings.
  if ($form_id == 'node_type_form') {
    include_once('media.admin.inc');
    media_settings_content_type($form, $form['#node_type']->type);
  }
}


/**
 * Implements hook_theme().
 * Register theming functions
 *
 * @return array
 */
function media_theme() {
  return array(
    // The media file browser form.
    'media_file_browser' => array(
      'arguments' => array('element' => NULL),
    ),

    // The default media file list form element.
    'media_file_list' => array(
      'arguments' => array('element' => NULL),
    ),

    // The media browser pane.
    'media_browser_pane' => array(
      'arguments' => array('form' => array()),
    ),

    // The thumbnail disply on admin pages.
    'media_admin_thumbnail' => array(
      'arguments' => array('file' => NULL),
      'file' => 'media_theme.inc',
    ),

    // The thumbnail operations disply on admin pages.
    'media_admin_thumbnail_operations' => array(
      'arguments' => array('file' => NULL),
      'file' => 'media_theme.inc',
    ),

    // The thumbnail operations disply on display pages.
    'media_admin_thumbnail_operations' => array(
      'arguments' => array('file' => NULL),
      'file' => 'media_theme.inc',
    ),

    // Media browser content frame
    'media_browser_content_frame' => array(
      'arguments' => array(
        'files' => NULL,
        'parameters' => NULL,
        'invoke' => false
      ),
      'file' => 'media_theme.inc',
    ),

    // The thumbnails disply on browser paness.
    'media_browser_thumbnails' => array(
      'arguments' => array('files' => NULL),
      'file' => 'media_theme.inc',
    ),

    // The navigation results limit control
    'media_browser_control_result_limit' => array(
      'arguments'=> array(
        'parameters' => null,
        'limits' => null
      ),
      'file' => 'media_theme.inc',
    ),

  );
}


/* ***************************************** */
/* Media Menu Callbacks                      */
/* ***************************************** */

/**
 * This is the ajax callback to reload data into the media
 * content browser.
 * @pram $object_type
 *   string, kind of object- node
 * @param $bundle
 *   string, name of the bundle
 * @param $field_name
 *   string, name of the field we are loading content for
 * @pararm $item
 *   string, one of subtabs, pane, ...
 * @return unknown
 */
function media_browser_dispatch($object_type = null, $bundle = null, $field_name = null, $item = null, $tabname = null) {
  // Create an array of parameters from our data
  $parameters = array(
    'object-type' => $object_type,
    'bundle' => $bundle,
    'field-name' => $field_name,
  );

  // If there is a tabname, pull it through
  if ($tabname) {
    $parameters['tabname'] = $tabname;
  }

  // What kind of thing are we rendering?
  switch ($item) {

    // SubTabs arethe content on the side of the content browser. They
    // are elements grouped under a main tab, defined in their registration.
    case 'subtabs':
      $return = drupal_render(drupal_get_form('media_browser_subtabs_form', $parameters));
    break;

    // Our default case just returns the requested data
    case 'pane':
    default:
      $query = drupal_get_query_parameters();

      // We need to be careful as this is not sanitized data.
      // @TODO can somebody check me here on this method
      // of cleaning the URL data?
      foreach ($query as $key => $value) {
        $url_args[check_plain($key)] = check_plain($value);
      }
      // Merge the parameters into the url args
      $parameters = array_merge($url_args, $parameters);
      // Get the registration responsible for this subpane content
      $function = media_get_registered_modules_get_callback($parameters['identifier']);
      // Return the callback data
      $return = $function($parameters);
    break;
  }

  return drupal_json_output($return);
}


/* ***************************************** */
/* Media API Functions                       */
/* ***************************************** */


/**
 * Gets all of the modules which register with Media.
 *
 * @param array $ids
 *   (Optional) If this contains an array of id strings, then return only the
 *   specified ids.
 * @param boolean $reset
 *   (Optional) If TRUE, then reset the static cache.
 * @return array
 *   An array of registrations, keyed by implementing function name, in the
 *   form of:
 *     'module' => The module implementing the hook.
 *     'uri' => The scheme the stream wrapper handles, default is 'public://'.
 *     'types' => The mime types this module handles, defaults to * (all).
 *     'name' => A human readable name, displayed on forms.
 *     'kind' => Kind of functionality: 'resource' or 'format'.
 *     'description' => A verbose description of functionality.
 *     'callbacks' => An array of key => functions called for data.
 *     'fields' => What field types does this functionality operate on?
 *     'validation' => @todo
 *     'display' => @todo
 */
function media_get_registered_modules($ids = NULL, $reset = FALSE) {
  static $registrations;
  // Only build cache the first time the function is called, or if we reset it.
  if (is_NULL($registrations) || $reset) {
    $registrations = array();
    // Get all the modules which implement hook_media_register().
    // Iterate through each registration defined by the implementing module.
    foreach (module_invoke_all('media_register') as $identifier => $registration) {
      // Unique identifier for this registration
      $registration['identifier'] = $identifier;
      // Translate strings now
      $registration['tab'] = isset($registration['tab']) ? t($registration['tab']) : null;
      // We need to build a machine name for the tab
      if ($registration['tab']) {
        $pattern = "/[^a-zA-Z-0-9]/";
        $registration['tab_machine'] = preg_replace($pattern, '_',  $registration['tab']);
      }

      $registration['subtab'] = isset( $registration['subtab']) ? t($registration['subtab']) : null;
      $registration['name'] = isset($registration['name']) ? t($registration['name']) : null;
      $registration['description'] = isset($registration['description']) ? t($registration['description']) : null;

      // Default the URI to public://.
      if (! isset($registration['uri']) || ! $registration['uri']) {
        $registration['uri'] = MEDIA_RESOURCE_URI_DEFAULT;
      }

      // Default 'types' to * (all).
      if (!isset($registration['types']) || !$registration['types']) {
        $registration['types'] = MEDIA_TYPES_DEFAULT;
      }

        // Add the new registration
        $registrations[$identifier] = $registration;
      }
    }

  // Return requested registrations.
  if ($ids) {
    foreach ($ids as $id) {
      $return[$id] = $registrations[$id];
    }
    return $return;
  }
  return $registrations;
}


/**
 *  Build a list of possible registration types.
 *  'resource' handles building file resource lists.
 *  'formatter' displays a list of file resources for the file browser.
 *  'attach' passes an FID to the registered module for handling.
 *
 *  @return array
 */
function media_registration_kinds() {
  return array('resource', 'formatter');
}


/**
 * Helper function to retrieve a list of all the tabs from
 * the registered modules
 * @return array
 */
function media_get_registered_modules_get_tabs() {
	$tabs = array();
	foreach(media_get_registered_modules() as $registration) {
		if (isset($registration['tab']) && $registration['tab']) {
		  $tabs[$registration['tab_machine']] = $registration['tab'];
		}
	}
	return $tabs;
}


/**
 * Helper function to retrieve a list of all subtabs
 * defined for this tab
 * @return array
 */
function media_get_registered_modules_get_subtabs($tab_name) {
  $subtabs = array();
  foreach(media_get_registered_modules() as $registration) {
  	if ($registration['tab_machine'] == $tab_name) {
      $subtabs[] = $registration;
  	}
  }
  return $subtabs;
}


/**
 * Helper function to get callback function for the specified
 * identifier
 * @param $identifier
 *   string, identifier of this registration
 * @param $type
 *   string, which callback to return
 * @return array
 */
function media_get_registered_modules_get_callback($identifier, $type = 'resource') {
  $registrations = media_get_registered_modules();
  return $registrations[$identifier]['callbacks'][$type];
}



/**
 * Get all fields that can be enabled on a field type.
 * @NOTE is this in use ? AF 11/13/09
 *  @TODO: Cache the results and retrieve from cache.
 *
 * @param string $field_type
 *   The field type to get items for.
 * @param string $function_type
 *   The kind of functionality being looked for.
 * @return array
 *   Array of full registration objects.
 */
function media_get_fields($field_type, $function_type = 'resource') {
  static $data;

  // Set up the initial static variable array.
  if (!isset($data)) {
    $data = array();
  }
  if (!isset($data[$field_type])) {
    $data[$field_type] = array();
  }

  // Do we have cached version?
  if (isset($data[$field_type][$function_type])) {
    return $data[$field_type][$function_type];
  }

  // So we have something to return, even if it's nothing.
  $data[$field_type][$function_type] = NULL;
  // Get all the registered modules.
  foreach (media_get_registered_modules() as $id => $registration) {
    // Check to see if this registration supports this function type.
    if ($registration['kind'] == $function_type) {
      // Now look for the fields.
      if ($registration['fields']) {
        foreach ($registration['fields'] as $field) {
          // If this registration supports this field type, add it to the
          // returned array.
          if ($field == $field_type) {
            $data[$field_type][$function_type][$id] = $registration;
          }
        }
      }
    }
  }

  return $data[$field_type][$function_type];
}


/* ***************************************** */
/*  Hook Implementations                     */
/* ***************************************** */

/**
 *  Implementation of hook_media_elements().
 *
 *  A Media File List element is created with the following FAPI:
 *    '#type' => 'media_file_list',
 *    '#options' => $options,         // An associative array of filepaths, keyed by FID.
 *    '#title' => $title,             // The translated title, displayed in the tab.
 *    '#description' => $description, // A translated description, to be displayed below the title.
 */
function media_element_info() {
  $elements = array();

  $elements['media_browser_thumbnails'] = array(
    '#input' => TRUE,
    '#process' => array('media_browser_thumbnails_process'),
    '#after_build' => array('media_browser_thumbnails_after_build'),
    '#validate' => array('media_browser_thumbnails_validate'),
    '#element_validate' => array('media_browser_thumbnails_element_validate'),
    '#pre_render' => array('media_browser_thumbnails_pre_render'),
    '#post_render' => array('media_browser_thumbnails_post_render'),
    '#submit' => array('media_browser_thumbnails_submit'),
  );

  $elements['media_file_list'] = array(
    '#input'            => TRUE,
    '#process'          => array('media_file_list_element_process'),
    '#element_validate' => array('media_file_list_element_validate'),
    '#submit'           => array('media_file_list_element_submit'),
  );

  $file_path = drupal_get_path('module', 'file');
  $elements['media_managed_file'] = array(
    '#input' => TRUE,
    '#process' => array('file_managed_file_process'),
    '#value_callback' => 'file_field_widget_value',
    '#element_validate' => array('file_managed_file_validate'),
    '#file_value_callbacks' => array('media_uri_value'),
    '#theme' => 'media_managed_file',
    '#theme_wrappers' => array('form_element'),
    '#progress_indicator' => 'throbber',
    '#progress_message' => NULL,
    '#upload_validators' => array(),
    '#upload_location' => NULL,
    '#extended' => FALSE,
    '#attached' => array(
      'css' => array($file_path . '/file.css'),
      'js' => array($file_path . '/file.js'),
    ),
  );

  return $elements;
}

/* ***************************************** */
/* Callbacks                                 */
/* ***************************************** */

/**
 * Process callback for the media_browser element.
 *
 * @param $element
 * @param $edit
 * @param $form_state
 * @param $form
 * @return array
 */
function media_file_list_element_process($element, $edit, $form_state, $form) {
  $element['list'] = array(
    '#type'     => 'select',
    '#options'  => $element['#options'],
    '#size'     => variable_get('media_file_list_size', 10),
  );

  return $element;
}

/**
 * Submit callback for the media_browser element.
 *
 * @param array $form
 * @param $form_state
 */
function media_file_list_element_submit(&$form, $form_state) {
  drupal_set_message(t('Successful submit of the Media File List...'));
}

/**
 * Validate callback for the media_browser element.
 *
 * @param $element
 * @param $form_state
 */
function media_file_list_element_validate($element, $form_state) {
  drupal_set_message(t('Successful validation of the Media File List...'));
  return $element;
}

/**
 * Validate callback for the media_browser metadata.
 *
 * @param array $form
 * @param $form_state
 */
function media_browser_metadata_validate(&$form, $form_state) {
  drupal_set_message(t('validating metadata... media_browser_metadata_validate needs to pass it to the registered module.'));
}

/**
 * Submit callback for the media_browser metadata.
 *
 * @param array $form
 * @param $form_state
 */
function media_browser_metadata_submit(&$form, $form_state) {
  drupal_set_message(t('media_browser_metadata_submit: last step... we now have metadata, and need to send that info to the registered module w/ the file info.'));
}

/**
 * Validate callback for the media_browser.
 *
 * @param array $form
 * @param $form_state
 */
function media_browser_validate(&$form, $form_state) {
  drupal_set_message(t('media_browser_validate is validating... needs to go to registered module from here.'));
}

/**
 * Submit callback for the media_browser.
 *
 * @param array $form
 * @param $form_state
 */
function media_browser_submit(&$form, $form_state) {
  drupal_set_message(theme('image', variable_get('media_file_progress_success', drupal_get_path('module', 'media') . '/images/check-green-blah.png')) . t('media_browser_submit File attachment: !file successful.', array('!file' => l($form_state['values']['media_files'], $form_state['values']['media_files']))));
  drupal_set_message(t('(media_browser_submit will need to actually process the file here, sending it to the original registered module to store. we also need to ensure the file is kept in synch with the metadata & formatter coming up next.)'));

  // To consider: Use module_implements to call all modules which implement this hook.
  // This might allow the modules to determine their own chaining, but at the expense of performance.
  // Order of operations and state would be an issue...
  //
  // Another alternative: Create a mechanism for before and after requirements. Example: a thumbnail creator would register
  // an action and with the registration provide a list of modules/functions that must run before the action it provides is run.
  // This would mean that for every action fire we would have to pull all of this together and build an action chain.
  // That could get horribly messy in the event of a race condition.
  //
  // For now just look for the specific module's hook and fire it off.
  $hook_media_action = $form_state['values']['registered_module'] . '_media_action';

  if (function_exists($hook_media_action)) {
    $hook_media_action($form, $form_state, 'media_browser_submit');
  }
  else {
    drupal_set_message(t('Media: No action handler found in media_browser_submit.'), 'error');
  }

  // dsm($form_state['values']);
}

/**
 * Implement hook_field_info_alter().
 */
function media_field_info_alter(&$info) {
  $info['file']['default_widget'] = 'media_generic';
}

function media_field_widget_info_alter(&$info) {
  // Don't allow users to choose the generic file upload widget
  // for new fields.
  unset($info['file_generic']);
}

/**
 * Implement hook_field_widget_info().
 */
function media_field_widget_info() {
  return array(
    'media_generic' => array(
      'label' => t('File (media)'),
      'field types' => array('file'),
      'settings' => array(
        'progress_indicator' => 'throbber',
        'allowed_schemes' => array('public', 'private'),
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
        'default value' => FIELD_BEHAVIOR_NONE,
      ),
    ),
  );
}

/**
 * Implement hook_field_widget_settings_form().
 */
function media_field_widget_settings_form($field, $instance) {

  // Get form for upload progress.
  $form = file_field_widget_settings_form($field, $instance);
  $widget = $instance['widget'];
  $settings = $widget['settings'];
  $streams = file_get_stream_wrappers();
  unset($streams['temporary']);
  foreach ($streams as $scheme => $data) {
    $options[$scheme] = t('@scheme (@name)', array('@scheme' => $scheme . '://', '@name' => $data['name']));
  }
  $form['allowed_schemes'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Allowed URI schemes'),
    '#options' => $options,
    '#default_value' => $settings['allowed_schemes'],
    '#description' => t('URI schemes include public:// and private:// which are the Drupal files directories, and may also refer to remote sites.'),
    '#weight' => 1,
  );
  return $form;
}


/**
 * Implementation of hook_field_widget().
 */
function media_field_widget(&$form, &$form_state, $field, $instance, $langcode, $items, $delta = 0) {
  // This code was originally copied from file.field.inc.
  $form['#attributes'] = array('enctype' => 'multipart/form-data');

  $defaults = array(
    'fid' => 0,
    'display' => !empty($field['settings']['display_default']),
    'description' => '',
    'file_uri' => '',
  );

  // Retrieve any values set in $form_state, as will be the case during AJAX
  // rebuilds of this form.
  if (isset($form_state['values'][$field['field_name']][$langcode])) {
    $items = $form_state['values'][$field['field_name']][$langcode];
    unset($form_state['values'][$field['field_name']][$langcode]);
  }

  foreach ($items as $delta => $item) {
    $items[$delta] = array_merge($defaults, $items[$delta]);
    // Remove any items from being displayed that are not needed.
    if ($items[$delta]['fid'] == 0) {
      unset($items[$delta]);
    }
  }

  // Re-index deltas after removing empty items.
  $items = array_values($items);

  // Update order according to weight.
  $items = _field_sort_items($field, $items);

  // Essentially we use the managed_file type, extended with some enhancements.
  $element_info = element_info('media_managed_file');
  $element = array(
    '#type' => 'media_managed_file',
    '#default_value' => isset($items[$delta]) ? $items[$delta] : $defaults,
    '#required' => $instance['required'],
    '#upload_location' => file_field_widget_uri($field, $instance),
    '#upload_validators' => file_field_widget_upload_validators($field, $instance),
    '#media_file_extensions' => $instance['settings']['file_extensions'],
    '#media_allowed_schemes' => $instance['widget']['settings']['allowed_schemes'],
    '#process' => array_merge($element_info['#process'], array('file_field_widget_process', 'media_generic_widget_process')),
    // Allows this field to return an array instead of a single value.
    '#extended' => TRUE,
    // Add extra Field properties.
    '#field_name' => $field['field_name'],
    '#bundle' => $instance['bundle'],
    '#object_type' => $instance['object_type'],
  );

  if ($field['cardinality'] == 1) {
    // If there's only one field, return it as delta 0.
    $element['#title'] = $instance['label'];
    if (empty($element['#default_value']['fid'])) {
      $element['#description'] = theme('file_upload_help', array('description' => $instance['description'], 'upload_validators' => $element['#upload_validators']));
    }
    $elements = array($element);
  }
  else {
    // If there are multiple values, add an element for each existing one.
    $delta = -1;
    foreach ($items as $delta => $item) {
      $elements[$delta] = $element;
      $elements[$delta]['#default_value'] = $item;
      $elements[$delta]['#weight'] = $delta;
    }
    // And then add one more empty row for new uploads.
    $delta++;
    if ($field['cardinality'] == FIELD_CARDINALITY_UNLIMITED || $delta < $field['cardinality']) {
      $elements[$delta] = $element;
      $elements[$delta]['#default_value'] = $defaults;
      $elements[$delta]['#weight'] = $delta;
      $elements[$delta]['#required'] = ($instance['required'] && $delta == 0);
    }
    // The group of elements all-together need some extra functionality
    // after building up the full list (like draggable table rows).
    $elements['#file_upload_delta'] = $delta;
    $elements['#theme'] = 'file_widget_multiple';
    $elements['#theme_wrappers'] = array('fieldset');
    $elements['#attributes']['class'] = array('media-file-widget');
    $elements['#process'] = array('file_field_widget_process_multiple');
    $elements['#title'] = $instance['label'];
    $elements['#description'] = $instance['description'];

    // Add some properties that will eventually be added to the file upload
    // field. These are added here so that they may be referenced easily through
    // a hook_form_alter().
    $elements['#file_upload_title'] = t('Add a new file');
    $elements['#file_upload_description'] = theme('file_upload_help', array('description' => '', 'upload_validators' => $elements[0]['#upload_validators']));
  }

  return $elements;
}


/**
 * An element #process callback for the media_managed_file type.
 *
 * Expands the media_managed_file type to include the uri field.
 */
function media_generic_widget_process($element, &$form_state, $form) {
  $fid = isset($element['fid']['#value']) ? $element['fid']['#value'] : 0;

  if (empty($fid)) {
    $element['file_uri'] = array(
      '#title' => t('File uri (for existing files)'),
      '#type' => 'textfield',
      '#maxlength' => 240,
      '#size' => 60,
    );

    // Provide attributes to allow us to pick up this field via jQuery
    $element['file_uri']['#attributes']['class'] = array('media-file-uri');
    $element['file_uri']['#attributes']['field-name'] = array($element['#field_name']);
    $element['file_uri']['#attributes']['bundle'] = array($element['#bundle']);
    $element['file_uri']['#attributes']['object-type'] = array($element['#object_type']);
  }

  // Load up all of our necessary jQuery
  drupal_add_library('system', 'vertical-tabs');
  drupal_add_library('system', 'ui');
  drupal_add_library('system', 'ui.draggable');
  drupal_add_library('system', 'ui.resizable');
  drupal_add_library('system', 'ui.dialog');
  drupal_add_library('system', 'ui.tabs');
  // Load our css.
  drupal_add_css(drupal_get_path('module', 'media') . '/media.css');
  // Load the custom JS
  drupal_add_js(drupal_get_path('module', 'media') . '/javascript/media.js');

  $i = false;
  // Fetch all defined tabs
  foreach (media_get_registered_modules_get_tabs() as $tab_machine => $tabname) {
  	$options = array('attributes' => array(
      'class' => ($i ? null : 'active'),
      'tabname' => $tab_machine,
      'field-name' => $element['#field_name'],
      'bundle' => $element['#bundle'],
      'object-type' => $element['#object_type']
    ));

	  $items[] = array(
	    'data' => l($tabname, '#', $options),
	    'class' => $i ? null : array('active'),
	  );
	  $i = true;
  }

  // Add a URL setting for the AJAX load
  drupal_add_js(array('media' => array(
    'media_browser_content_load_url' => base_path() . 'media/browser/dispatch',
    'media_browser_tabs' => theme('item_list', array('items' => $items, 'attributes' => array('class' => 'tabs primary', 'onclick' => 'javascript: return false;')))
  )),
  array('type' => 'setting'));

  return $element;
}

/**
 * A #file_value_callbacks for the media_managed_file type.
 *
 * This callback taks a URI string, validates it and alows the
 * file to be attached if it's valid.  This is called by function
 * file_managed_file_value() if the user has not browsed for a
 * file (i.e. function file_managed_file_save_upload() finds nothing
 * in $_FILES['files']['name']).
 */
function media_uri_value($element, &$input) {
  if (!empty($input['file_uri'])) {
    $upload_name = implode('_', $element['#parents']);
    $scheme = file_uri_scheme($input['file_uri']);
    $target = file_uri_target($input['file_uri']);
    if (!$scheme || !$target) {
      form_set_error($upload_name, t('Invalid URI.'));
      return;
    }
    $file = new stdClass;
    $file->filename = basename($target);
    $streams = file_get_stream_wrappers();
    if (empty($streams[$scheme])) {
      form_set_error($upload_name, t('Invalid URI: scheme is not registered.'));
      return;
    }
    elseif (!in_array($scheme, $element['#media_allowed_schemes'], TRUE)) {
      form_set_error($upload_name, t('Invalid URI: scheme @scheme:// is not allowed for this field instance.', array('@scheme' => $scheme)));
      return;
    }
    elseif ($scheme == 'public' || $scheme == 'private') {
      $errors = file_validate_extensions($file, $element['#media_file_extensions']);
      if ($errors) {
        form_set_error($upload_name, implode(' ', $errors));
        return;
      }
    }
    else {
      // TODO: check a list of allowed scheme per field instance.
    }

    $files = file_load_multiple(array(), array('uri' => $input['file_uri']));
    if (!empty($files)) {
      $file = array_pop($files);
      $input['fid'] = $file->fid;
      return;
    }

    if (file_exists($input['file_uri']) && is_readable($input['file_uri'])) {
      $wrapper = file_stream_wrapper_get_instance_by_uri($input['file_uri']);
      $file->uri = $input['file_uri'];
      $file->status = FILE_STATUS_PERMANENT;
      $file->uid = $GLOBALS['user']->uid;
      $file->filemime = $wrapper->getMimeType($input['file_uri']);
      $file = file_save($file);
      if (isset($file->fid)) {
        $input['fid'] = $file->fid;
        return;
      }
    }
    form_set_error($upload_name, t('The file could not be uploaded.'));

    $input['fid'] = 0;
  }
}


/**
 * Implement hook_file_references().
 *
 * Important - without implementing this hook, it's hard insert an existing
 * file into the file table and attach to a node due to validation in
 * function file_managed_file_validate() in file.module.
 */
function media_file_references($file) {
  return 1;
}


/**
 * Implement hook_image_default_styles().
 */
function media_image_default_styles() {
  $styles = array();
  $styles['square_thumbnail'] = array(
    'effects' => array(
      array(
        'name' => 'image_scale_and_crop',
        'data' => array('width' => 180, 'height' => 180),
        'weight' => 0,
      ),
    )
  );

  return $styles;
}


/* *************************************************** */
/* Media display forms                                 */
/* *************************************************** */


/**
 * Build the tabs across the media browser
 * @param $parameters
 *   array, provides validation and selection criteria
 * @return unknown_type
 */
function media_browser_subtabs_form($form, &$form_state, $parameters) {
	// We are making vertical tabs
  $form['subtabs'] = array('#type' => 'vertical_tabs');
  // Load all the subtabs for this tab
  foreach(media_get_registered_modules_get_subtabs($parameters['tabname']) as $subtab) {
  	$form[$subtab['identifier']] = array(
  	  '#type' => 'fieldset',
  	  '#title' => $subtab['subtab'],
  	  '#group' => 'subtabs',
  	);
  	// Clean this little mess up
  	$element_params = array_merge(array('identifier' => $subtab['identifier']), $parameters);
  	$element_params['class'] .= ' subtab_data';

  	$form[$subtab['identifier']]['data'] = array(
  	  '#type' => 'hidden',
  	  '#attributes' => $element_params,
  	  '#value' => $id,
  	);

  	// This provides a place to render our content
  	$form[$subtab['identifier']]['markup'] = array('#markup' => '<div class="pane_content"></div>');
  }

  return $form;
}


/**
 * Creates the file list display form
 *
 * @param unknown_type $form
 * @param unknown_type $form_state
 * @param $files
 *   array of Drupal file objects
 * @param $parameters
 *   array of current display settings
 * @return array drupal form
 *
 */
function media_file_listing_form($form, $form_state, $files, $parameters) {
  $form['files'] = array(
   '#tree' => TRUE,
   '#prefix' => '<div class ="media-display-thumbnails clearfix">',
   '#suffix' => '</div>',
  );
  if (count($files)) {
    foreach ($files as $id => $file) {
     $form['files'][$id] = array(
       '#type' => 'checkbox',
       '#return_value' => $file->uri,
       '#title' => check_plain($file->filename),
       '#prefix' => '<div class="media-thumbnail">' . theme('media_browser_thumbnails', array('file' => $file)),
       '#suffix' => '</div>',
     );
    }
  }

  // Unset the page value in options so that the pager can
  // control which page the link refers to
  unset($parameters['page']);
  $form['pager'] = array('#markup' => theme('pager', array('parameters' => $parameters)));

  // Build the display switch.
  // @TODO support this correctly
  // require_once('media.admin.inc');
  // $form = media_admin_display_switch($form, array('active_display' => 'thumbnails'));
  return $form;
}


/**
 * @TODO can somebody document this?
 *
 * @param unknown_type $variables
 * @return unknown
 */
function theme_media_managed_file($variables) {
  $element = $variables['element'];

  // This wrapper is required to apply JS behaviors and CSS styling.
  $output = '';
  $output .= '<div class="form-managed-file">';
  $output .= drupal_render_children($element);
  $output .= '</div>';
  return $output;
}
<?php
// $Id:

/**
* Implementation of hook_node_name().
*/
function media_node_name($node) {
  switch (is_string($node) ? $node : $node->type) {
    case 'media-playlist':
      return t('media-playlist');
  }
}

/**
 * Implementation of hook_node_types.
 * 
 * TODO: This hook is not strictly necessary since there is only one node type,
 * playlist. Determine benefits or drawbacks to having this hook.
 */
function media_node_types() {
  return array('media-playlist');
}

/**
 * Implementation of hook_help
 */
function media_help($section) {
  switch ($section) {
    case 'admin/modules#description' :
      $output = t('Enables attached multimedia content and creation of playlists.');
    case 'node/add#media-playlist' :
      $output = t('Create a list of songs or movies from the media database.');
  }
  return $output;
}

/**
 * Hook to react to file events. This currently gets called from the upload
 * module whenever a file is inserted, updated, loaded or deleted.
 * 
 * For the media module, update and insert both depend on the external getID3
 * library to read the metadata from audio and video files. 
 */
function media_file($op, &$file) {
  switch ($op) {
    
    case 'update':
    case 'insert':
      if (media_is_supported_type($file->filemime)) {
    
        media_include_library();
    
        // initialize library and get file information
        $getID3 = new getID3;
        $audioinfo = $getID3->analyze($file->_filename);
        $audioinfo = media_array_to_columns(NULL, $audioinfo);
        $audioinfo = array2object($audioinfo);
    
        // add the meta-data to the $file object. Uses ? : syntax to only add the variable if it is present.
        $audioinfo->fileformat ? $file->fileformat = $audioinfo->fileformat : $audioinfo->fileformat;
        $audioinfo->audio_dataformat ? $file->audio_dataformat = $audioinfo->audio_dataformat : $audioinfo->audio_dataformat;
        $audioinfo->audio_channels ? $file->audio_channels = $audioinfo->audio_channels : $audioinfo->audio_channels;
        $audioinfo->audio_sample_rate ? $file->audio_sample_rate = $audioinfo->audio_sample_rate : $audioinfo->audio_sample_rate;
        $audioinfo->audio_bitrate ? $file->audio_bitrate = $audioinfo->audio_bitrate : $audioinfo->audio_bitrate;
        $audioinfo->audio_channelmode ? $file->audio_channelmode = $audioinfo->audio_channelmode : $audioinfo->audio_channelmode;
        $audioinfo->audio_compression ? $file->audio_compression = $audioinfo->audio_compression : $audioinfo->audio_compression;
        $audioinfo->audio_codec ? $file->audio_codec = $audioinfo->audio_codec : $audioinfo->audio_codec;
        $audioinfo->audio_encoder ? $file->audio_encoder = $audioinfo->audio_encoder : $audioinfo->audio_encoder;
        $audioinfo->video_bitrate ? $file->video_bitrate = $audioinfo->video_bitrate : $audioinfo->video_bitrate;
        $audioinfo->video_resolution_x ? $file->video_resolution_x = $audioinfo->video_resolution_x : $audioinfo->video_resolution_x;
        $audioinfo->video_resolution_y ? $file->video_resolution_y = $audioinfo->video_resolution_y : $audioinfo->video_resolution_y;
        $audioinfo->video_frame_rate ? $file->video_frame_rate = $audioinfo->video_frame_rate : $audioinfo->video_frame_rate;
        $audioinfo->video_pixel_aspect_ratio ? $file->video_pixel_aspect_ratio = $audioinfo->video_pixel_aspect_ratio : $audioinfo->video_pixel_aspect_ratio;
        $audioinfo->video_bits_per_sample ? $file->video_bits_per_sample = $audioinfo->video_bits_per_sample : $audioinfo->video_bits_per_sample;
        $audioinfo->video_codec ? $file->video_codec = $audioinfo->video_codec : $audioinfo->video_codec;
        $audioinfo->video_compression_ratio ? $file->video_compression_ratio = $audioinfo->video_compression_ratio : $audioinfo->video_compression_ratio;
        $audioinfo->encoding ? $file->encoding = $audioinfo->encoding : $audioinfo->encoding;
        $audioinfo->playtime_seconds ? $file->playtime_seconds = $audioinfo->playtime_seconds : $audioinfo->playtime_seconds;
        $audioinfo->playtime_string ? $file->playtime_string = $audioinfo->playtime_string : $audioinfo->playtime_string;
    
        $title = '/id3v[1-9]_title/';
        $artist = '/id3v[1-9]_artist/';
        $album = '/id3v[1-9]_album/';
        $year = '/id3v[1-9]_year/';
        $comment = '/id3v[1-9]_comment/';
        $track = '/id3v[1-9]_track/';
        $genre = '/id3v[1-9]_genre/';
    
        foreach ($audioinfo as $name => $value) {
          if (preg_match($title, $name)) {
            $file->id3_title = $value;
          } else
            $file->id3_title = $file->filename;
          if (preg_match($artist, $name)) {
            $file->id3_artist = $value;
          }
          if (preg_match($album, $name)) {
            $file->id3_album = $value;
          }
          if (preg_match($year, $name)) {
            $file->id3_year = $value;
          } else
            $file->id3_year = date('Y');
          if (preg_match($comment, $name)) {
            $file->id3_comment = $value;
          }
          if (preg_match($track, $name)) {
            $file->id3_track = $value;
          }
          if (preg_match($genre, $name)) {
            $file->id3_genre = $value;
          }
        }
    if ($file->video_bitrate > 0) {         
      db_query('INSERT INTO {video_metadata} (fid, fileformat, video_bitrate, video_resolution_x, video_resolution_y,'.
        'video_frame_rate, video_pixel_aspect_ratio, video_bits_per_sample,'. 
        'video_codec, video_compression_ratio, encoding, playtime_seconds,'.
        'playtime_string) '. 
        'VALUES ('.
          "%d,". // fid
          "'%s',". // fileformat
          "%d,". // video_bitrate
          "%d,". // video_resolution_x
          "'%s',". // video_resolution_y
          "'%s',". // video_frame_rate
          "%d,". // video_pixel_aspect_ratio
          "%d,". // video_bits_per_sample
          "'%s',". // video_codec
          "'%s',". // video_compression_ratio
          "'%s',". // encoding
          "'%s',". //playtime_seconds
          "'%s'". // playtime_string
        ")", 
      $file->fid, $file->fileformat, $file->audio_dataformat, $file->audio_channels, $file->audio_sample_rate, $file->audio_bitrate, $file->audio_channelmode, $file->audio_compression_ratio, $file->audio_codec, $file->audio_encoder, $file->video_bitrate, $file->video_resolution_x, $file->video_resolution_y, $file->video_frame_rate, $file->video_pixel_aspect_ratio, $file->video_bits_per_sample, $file->video_codec, $file->video_compression_ratio, $file->id3_title, $file->id3_artist, $file->id3_album, $file->id3_comment, $file->id3_track, $file->id3_genre, $file->id3_year, $file->encoding, $file->playtime_seconds, $file->playtime_string);
    }
    else {
      db_query('INSERT INTO {audio_metadata} (fid, fileformat, audio_dataformat, '.
        'audio_channels, audio_sample_rate, audio_bitrate, audio_channelmode, '.
        'audio_compression_ratio, audio_codec, audio_encoder, id3_title, id3_artist, '.
        'id3_album, id3_comment, id3_track, id3_genre, id3_year, '.
        'encoding, playtime_seconds, playtime_string) '.
        'VALUES ('.
          '%d, '. // fid
          "'%s', ". // fileformat
          "'%s', ". // audio_dataformat
          '%d, '. // audio_channels
          '%d, '. // audio_sample_rate
          '%d, '. // audio_bitrate
          "'%s', ". // audio_channelmode
          "'%s', ". // audio_compression_ratio
          "'%s', ". // audio_codec
          "'%s', ". //audio_encoder
          "'%s', ". // id3_title
          "'%s', ". // id3_artist
          "'%s', ". // id3_album
          "'%s', ". // id3_comment
          "'%s', ". // id3_track
          "'%s', ". // id3_genre
          "'%s', ". // id3_year
          "'%s', ". // encoding
          "'%s', ". // playtime_seconds
          "'%s' )",// playtime_string
        $file->fid, $file->fileformat, $file->audio_dataformat, $file->audio_channels, 
        $file->audio_sample_rate, $file->audio_bitrate, $file->audio_channelmode, 
        $file->audio_compression_ratio, $file->audio_codec, $file->audio_encoder, 
        $file->id3_title, $file->id3_artist, $file->id3_album, $file->id3_comment, 
        $file->id3_track, $file->id3_genre, $file->id3_year, $file->encoding, 
        $file->playtime_seconds, $file->playtime_string);
       
      }
    }
    break;
    
    case 'delete':
      if (media_is_supported_type($file->filemime)) {
        if ($file->video_bitrate) {         
          db_query("DELETE FROM {video_metadata} WHERE fid=%d", $file->fid);
        }
        else {
          db_query("DELETE FROM {audio_metadata} WHERE fid=%d", $file->fid);
        }
        //  code for automatic removal of individual items from playlists on deletion of a file
        // get current playlists containing the deleted file
        $result = db_query("SELECT * FROM {av_playlist} WHERE fid = %d OR next_fid = %d", $file->fid, $file->fid);
    
        $playlists = array();
        while ($data_row = db_fetch_array($result)) {
           $playlists[$row['nid']][] = $row;
        }
        
        foreach ($playlists as $node_id => $data) {
          // if only one item within the playlist contains this fid, then it's the first
          // item on the list - just delete it.
          if (1 == count($data)) {
            unset ($playlists[$node_id]);
          }
          // otherwise get its predecessor, insert the new next_fid (taken from the item to be
          // deleted) and delete the entry containing the file.
          else {
            if ($data[0]['fid'] == $file->fid) {
              $playlists[$node_id][1]['next_fid'] = $playlists[$node_id][0]['next_fid'];
              unset ($playlists[$node_id][0]);
            } else {
              $playlists[$node_id][0]['next_fid'] = $playlists[$node_id][1]['next_fid'];
              unset ($playlists[$node_id][1]);
            }
          }
        }
    
        // save changes to the database
        db_query('DELETE FROM {av_playlist} WHERE fid = %d OR next_fid = %d', $file->fid, $file->fid);
        foreach ($playlists as $data) {
          foreach ($data as $playlist_item) {
            db_query('INSERT INTO {av_playlist} (nid, fid, next_fid) VALUES (%d, %d, %d)', $playlist_item['nid'], $playlist_item['fid'], $playlist_item['next_fid']);
          }
        }
      }
      
    break;
    
    case 'load':
      if (media_is_supported_type($file->filemime)) {
        if ($file->video_bitrate) {
          $fileinfo = db_fetch_array(db_query("SELECT * FROM {video_metadata} WHERE fid = %d", $file->fid));
        } else {
          $fileinfo = db_fetch_array(db_query("SELECT * FROM {video_metadata} WHERE fid = %d", $file->fid));
        }  
        if (is_array($fileinfo)) {
          foreach ($fileinfo as $name => $value) {
            $file->$name = $value;
          }
        }
      }    
    break;
    
  }
}

/**
 * Implementation of hook_delete. Removes a media-playlist node from the
 * database.
 */
function media_delete(&$node) {
  if ($node->type == 'media-playlist') {
    db_query('DELETE FROM {av_playlist} WHERE nid = %d', $node->nid);
  }
}

/**
 * Implementation of hook_insert. Adds a media-playlist node to the database.
 * 
 * TODO: in the current implementation, the $_SESSION['playlist'] is cleared for
 * a user any time they create a playlist. This isn't technically correct. Only
 * after saving or clearing the playlist in the session should it be cleared.
 * Creating a new playlist by using the create-content link should not clear a
 * $_SESSION stored playlist.
 */
function media_insert($node) {
  if ($node->type == 'media-playlist') {
    if ($node->nid) {
      $playlist = unserialize($_SESSION['playlist']);
      $playlist_data = array ();
      if (is_array($playlist)) {
        foreach ($playlist as $index => $playlist_item) {
          $playlist_next = ($playlist[($index + 1)]) ? $playlist[($index + 1)] : -1;
          $playlist_data[] = sprintf('(%d, %d, %d)', $node->nid, $playlist_item, $playlist_next);
        }
        $values = implode(', ', $playlist_data);
        db_query("DELETE FROM {av_playlist} WHERE nid = %d", $node->nid);
        db_query("INSERT INTO {av_playlist} (nid, fid, next_fid) VALUES $values");
      }
      unset($_SESSION['playlist']);
   
    }
  }
}

/**
 * Implementation of the hook_load. Loads a media-playlist.
 */
function media_load($node) {
  if ('media-playlist' == $node->type) {
    if ($node->nid) {
      $result = db_query('SELECT * FROM {av_playlist} WHERE nid = %s', $node->nid);
      $playlist = array();
      while ($row = db_fetch_array($result)) {
        $playlist_db[] = $row;  
      }
      $playlist_db = media_playlist_sort_init($playlist_db);
      foreach ($playlist_db as $row) {
        $fid = $row['fid'];
        if (!empty($fid)) {
          $file = db_fetch_object(db_query("SELECT * FROM {files} WHERE fid = %d", $fid));

          // add metadata
          media_fileapi('load', $file);
          $playlist[] = array ('fid' => $fid, 'title' => ($file->id3_title) ? $file->id3_title : $file->filename);
          $playlist_data[] = $fid;
        }
      }
    } else {
      $playlist_data = unserialize($_SESSION['playlist']);

      if (is_array($playlist_data)) {
//      $playlist_data = media_playlist_sort_init($playlist_data);
        foreach ($playlist_data as $fid) {
          $file = db_fetch_object(db_query("SELECT * FROM {files} WHERE fid = %d", $fid));
          media_fileapi('load', $file);
          $playlist[] = array ('fid' => $fid, 'title' => ($file->id3_title) ? $file->id3_title : $file->filename);
        }
      }
    }
    $additions = new stdclass;
    $additions->playlist = $playlist;
  }
  return $additions ;
}

/**
 * Implementation of hook update. 
 * 
 * Same concern for unsetting the $_SESSION playlist as above
 */
function media_update($node) {
  if ($node->nid && 'media-playlist' == $node->type) {
    $playlist = unserialize($_SESSION['playlist']);
    if (is_array($playlist)) {
      foreach ($playlist as $index => $playlist_item) {
        $playlist_next = ($playlist[($index +1)]) ? $playlist[($index +1)] : -1;
        $playlist_data[] = sprintf('(%d, %d, %d)', $node->nid, $playlist_item, $playlist_next);
      }
      $values = implode(', ', $playlist_data);
      db_query("DELETE FROM {av_playlist} WHERE nid=%d", $node->nid);
      db_query("INSERT INTO {av_playlist} (nid, fid, next_fid) VALUES $values");
      unset($_SESSION['playlist']);
    }
  }
}

/**
 * Implementation of hook_view. 
 */
function media_view(&$node, $teaser = FALSE, $page = FALSE) {
  if ('media-playlist' == $node->type) {
    if ($_POST['playlist_play']) {
      media_playlist_play($_POST['playlist']);
    }

    $node->body .= media_playlist_show($node, $teaser);
  }
}

/**
* Implementation of hook_form.
* Adds the playlist information to the playlist node form
* TODO: change textarea to a sortable table.
*/
function media_form(&$node, &$param) {

  if ('media-playlist' == $node->type) {
    $output = t('Please enter a title for your playlist here.  If you have not already done so, you will be able to select the content that you want to include in your playlist on the next page by clicking on the add/change content tab.').'<br /><br />';

    // If this page was arrived at by clicking "create content -> playlist", then wipe the current playlist session
    // otherwise $_GET['plsave'] is set to 1 from the multimedia table page
    if (('node' == arg(0)) && 
        ('add' == arg(1)) && 
        (!isset ($_GET['plsave']))) {
         unset($_SESSION['playlist']);
    }
    else if (is_numeric(arg(1))) {
      $playlist_data = array ();
      $playlist = array();
      $result = db_query("SELECT * FROM {av_playlist} WHERE nid = %d", $node->nid);
      if (FALSE != $result) {
        while ($data = db_fetch_array($result)) {
          $playlist[] = $data;
        }
        $playlist = media_playlist_sort_init($playlist);
        foreach ($playlist as $file) {
          $playlist_data[] = $file['fid'];  
        }
        $_SESSION['playlist'] = serialize($playlist_data);
      }
    }
  }
  return t($output);
}

/**
* Implementation of hook_menu().
* adds the audio link to the settings area
* defines audio_admin as the callback function and 'administer audio' the permission needed to access the link.
*
*/
function media_menu($may_cache) {
  $items = array ();

  if ($may_cache) {
    $items[] = array ('path' => 'media', 
      'title' => t('multi-media'), 
      'callback' => 'media_page', 
      'access' => user_access('access content'), 
      'type' => MENU_SUGGESTED_ITEM);
    $items[] = array ('path' => 'node/add/media-playlist', 
      'title' => t('media-playlist'), 
      'access' => user_access('create media nodes'));
    $items[] = array ('path' => 'media/audio', 
      'title' => t('audio'), 
      'type' => MENU_DEFAULT_LOCAL_TASK, 
      'weight' => -10);
    $items[] = array ('path' => 'media/audio/browse', 
      'title' => t('browse'), 
      'callback arguments' => array ('audio', FALSE), 
      'type' => MENU_DEFAULT_LOCAL_TASK, 
      'weight' => -10);
    $items[] = array ('path' => 'media/audio/playlist', 
      'title' => t('create playlist'), 
      'callback arguments' => array ('audio', TRUE), 
      'access' => user_access('create playlists'), 
      'type' => MENU_LOCAL_TASK, 
      'weight' => -5,);
    $items[] = array ('path' => 'media/video', 
      'title' => t('video'), 
      'callback' => 'media_page', 
      'callback arguments' => array ('video'), 
      'type' => MENU_LOCAL_TASK);
    $items[] = array ('path' => 'media/video/browse', 
      'title' => t('browse'), 
      'callback arguments' => array ('video', FALSE), 
      'type' => MENU_DEFAULT_LOCAL_TASK, 
      'weight' => -10);
    $items[] = array ('path' => 'media/video/playlist', 
      'title' => t('create playlist'), 
      'callback arguments' => array ('video', 'playlist_create' => TRUE), 
      'access' => user_access('create playlists'), 
      'type' => MENU_LOCAL_TASK, 
      'weight' => -5,);
  } else 
    if (arg(0) == 'node' && is_numeric(arg(1))) {
      $node = node_load(array ('nid' => arg(1)));
      if ('media-playlist' == $node->type) {
        $items[] = array ('path' => 'node/'.arg(1).'/content', 
          'title' => t('add/change content'), 
          'callback' => 'media_page', 
          'callback arguments' => array ('audio', 'playlist_create' => TRUE, arg(1)), 
          'access' => (user_access('edit own playlists')), 
          'weight' => 5, 
          'type' => MENU_LOCAL_TASK);
        $items[] = array ('path' => 'node/'.arg(1).'/content/audio', 
          'title' => t('audio'), 
          'callback' => 'media_page', 
          'callback arguments' => array ('audio', 'playlist_create' => TRUE, arg(1)), 
          'access' => (user_access('edit own playlists')), 
          'weight' => 5, 
          'type' => MENU_DEFAULT_LOCAL_TASK);
        $items[] = array ('path' => 'node/'.arg(1).'/content/video', 
          'title' => t('video'), 
          'callback' => 'media_page', 
          'callback arguments' => array ('video', 
          'playlist_create' => TRUE, arg(1)), 
          'access' => (user_access('edit own playlists')), 
          'weight' => 5, 
          'type' => MENU_LOCAL_TASK);
      }
    }

  return $items;
}


/**
*
* menu callback - produces the audio page
*
*/
function media_page($medium = 'audio', $playlist_create = FALSE, $playlist_edit = NULL) {
  $instructions = theme('media_page_instructions', t('A sortable table of the contents of the media database.  Click on any of the highlighted column headings to sort by that column.  Click on the small arrow to change the order of sorting.'));

  $playlist_data = media_event_handler($playlist_edit);

  $table = call_user_func("media_${medium}_table", $playlist_create);

  if (TRUE == $playlist_create) {
    $playlist = array ();
    $playlist_fids = array ();

    if (is_array($playlist_data)) {
      foreach ($playlist_data as $fid) {

        $file = media_get_file_by_id($fid);
        if (!empty ($file->fid)) {
          $playlist[] = $file->filename;
          $playlist_fids[] = $file->fid;
        }
      }
    }

    $form = '';

    // create hidden form elements of each playlist fid - POSTs an array $_POST['playlist'] back.
    foreach ($playlist_fids as $fid) {
      $form .= '<input type="hidden" name="playlist[]" value="'.$fid.'">';
    }

    $playlist = implode("\r\n", $playlist);
    $form .= form_textarea(t('Playlist'), 'Playlist', $playlist, 50, 10, '', array ('readonly' => 'readonly'));
    $form .= form_button(t('Play'),'playlist_play');
    $form .= form_button(t('Clear'),'playlist_clear');
    $form .= form_button(t('Save'), 'playlist_save');

    $form = form_group(t('Your current playlist selections'), $form);

    $form = form($form, 'POST', url($_GET['q']));
  }
  
  $output = theme('media_table_page', $instructions, $table, $form);
  print theme('page', $output);

}

/**
 * override this in your theme to change the instructions on the media page.
 */
function theme_media_page_instructions($text) {
  return '<div id="media_instructions">'.$text.'</div>';
}

/**
 * override this in your theme to change the layout of the media page
 */
function theme_media_table_page($instructions, $table, $form) {
  return $instructions.$table.'<div class="form">'.$form.'</div>';
}

/**
 * renders a playlist
 * 
 * TODO: extract elements that should be in theme functions
 */
function media_playlist_show(&$node, $teaser) {
  $playlist = array ();
  $playlist_fids = array ();

  $teaser_max_no_items = variable_get('media_playlist_teaser_max_no_items', 5);

  if (is_array($node->playlist)) {
    foreach ($node->playlist as $song) {
      $playlist[] = $song['title'];
      $playlist_fids[] = $song['fid'];
    }
  }

  $form = '';

  if ($teaser) {
    if (count($playlist) > $teaser_max_no_items) {
      $playlist = array_slice($playlist, 0, $teaser_max_no_items);
      $playlist[] = ' . . . ';
    }
  }

  foreach ($playlist_fids as $fid) {
    $form .= '<input type="hidden" name="playlist[]" value="'.$fid.'">';
  }
  
  // if playlist data has not been loaded (preview), try and load it now  
  if (empty ($playlist)) {
    $temp_playlist = media_load($node);
    if (is_array($temp_playlist->playlist)) {
      foreach ($temp_playlist->playlist as $playlist_item) {
        $playlist[] = $playlist_item['title'];
      }
    }
  }

  if (is_array($playlist)) {
    $form .= theme('item_list', $playlist, 'Playlist');
  }
  $form .= form_button(t('Play'), 'playlist_play');
  $form = form_group(t('Your current playlist selections'), $form);

  $output .= form($form, 'POST');
  
  return $output ;
}

/**
 * Reacts to user interactions with the playlist.
 * 
 * User actions include clear, save, play, stream and delete
 */
function media_event_handler($playlist_edit = NULL) {
  $playlist_data = unserialize($_SESSION['playlist']);
  $playlist_data = $playlist_data ? $playlist_data : array(); 

  if ($_GET['pl_add'] && !$_POST['playlist_play'] && !$_POST['playlist_clear']) {
    if (!is_array($playlist_data) || !in_array($_GET['pl_add'], $playlist_data)) {
      $playlist_data[] = $_GET['pl_add'];
      $_SESSION['playlist'] = serialize($playlist_data);
    }
  }

  if ($_POST['playlist_clear']) {
    $playlist_data = array ();
    unset($_SESSION['playlist']);
  }

  // get the current playlist session info from the database

  if ($_POST['playlist_save']) {
    if (is_numeric($playlist_edit) && ($playlist_edit != 0)) {
      foreach ($playlist_data as $index => $playlist_item) {
        $playlist_next = ($playlist_data[($index +1)]) ? $playlist_data[($index +1)] : -1;
        $playlist_node_data[] = sprintf('(%d, %d, %d)', $playlist_edit, $playlist_item, $playlist_next);
      }

      if (!empty ($playlist_node_data)) {
        $values = implode(', ', $playlist_node_data);
        db_query("DELETE FROM {av_playlist} WHERE nid = %d", $playlist_edit);
        db_query("INSERT INTO {av_playlist} (nid, fid, next_fid) VALUES $values");
      } else {
        db_query("DELETE FROM {av_playlist} WHERE nid=%d", $playlist_edit);
      }
    }

    $_SESSION['playlist'] = serialize($playlist_data);

    if (!is_numeric($playlist_edit)) {
      drupal_goto('node/add/media-playlist', 'plsave=1');
    } else {
      drupal_set_message(t('Your playlist has been saved.'));
      unset($_SESSION['playlist']);
      drupal_goto('node/'.$playlist_edit);
    }
  }

  if ($_POST['playlist_play']) {
    media_playlist_play($_POST['playlist']);
  }

  if ($_GET['stream']) {
    media_stream_track($_GET['stream']);
  }
  return $playlist_data;
}


/**
* Implementation of hook_link().
*/
function media_link($type, $node = 0, $main) {
  $links = array ();
  if ($type == 'page' && user_access('access content')) {
    $links[] = l(t('multimedia'), 'media', array ('title' => t('View all available multimedia content')));
  }
  return $links;
}

/**
 * Implementation of hood_perm.
 * 
 * TODO: The two permissions dealing with media nodes are an artifact of the
 * past and need to be removed. Their removal needs to be coordinated with
 * changes to the media_access hook as well as a code audit to make sure there
 * are no more dependencies on the two permissions.
 */
function media_perm() {
  return array ('create media nodes','edit own media nodes','create playlists','edit own playlists','download media','stream media');
}

/**
 * Implementation of node_access
 * 
 * TODO: currently checks for deprecated permissions that need to be removed.
 * Should instead check to see if the user has the rights necessary to create,
 * update and delete playlists.
 */
function media_access($op, $node) {
  global $user;

  if ($op == 'create') {
    // Only users with permission to do so may create this node type.
    return user_access('create media nodes');
  }

  // Users who create a node may edit or delete it later, assuming they have the
  // necessary permissions.
  if ($op == 'update' || $op == 'delete') {
    if (user_access('edit own media nodes') && ($user->uid == $node->uid)) {
      return TRUE;
    }
  }
}

/**
* settings for the administration of the media module
* lets the user define a path to the ID3 library
* 
* Lets administrator determine which file types are valid media files.
* 
* TODO: Administrator should be able to decide which columns of the various
* tables are to be displayed.
*/
function media_settings() {
         
  $id3_path = $edit['path_to_id3'] ? $edit['path_to_id3'] : variable_get('media_path_to_id3', 'modules/media/getid3/getid3.php');
  if (!file_exists($id3_path)) {
    form_set_error('path_to_id3', t('The the file %file does not exist.', array ('%file' => "<em>$id3_path</em>")));
  }
  $form = form_textfield(t('Path to getid3.php'), 'path_to_id3', variable_get('media_path_to_id3', 'modules/media/getid3/getid3.php'), 30, t('In order to set up the media module\'s supported types, please supply the full correct path to the file getid3.php.'));

  foreach (range(1, 20) as $number) {
    $select_options[$number] = $number;
  }
  $form .= form_select(t('Maximum number of items in a playlist \'teaser\''), 'teaser_max_no_items', variable_get('media_playlist_teaser_max_no_items', 5), $select_options, $description = NULL);

  $header = array (t('Mime type'), t('Save this type\'s attributes'));
  $supported_types = variable_get('media_supported_types', media_get_supported_types());
  ksort($supported_types);
  foreach ($supported_types as $type => $supported) {
    $checkbox = form_checkbox('', "media_supported_types][$type", 1, $supported);
    $rows[] = array ($type, $checkbox);
  }

  if (is_array($rows)) {
    $form .= theme_table($header, $rows);
  }
  return $form;
}


/**
 * Makes sure that the ID3 library is included once without breaking Drupal just
 * by loading the module.
 * 
 * TODO: use drupal function for the same?
 * 
 * TODO: alert administrator on settings page if library isn't found
 */
function media_include_library() {
  // get the library for reading tag information
  $id3_path = variable_get('media_path_to_id3', 'modules/media/getid3/getid3.php');
  require_once ($id3_path);
}
/**
 * Returns a boolean based on the defined media types (admin/settings/media)
 * 
 * TODO: Split supported types into audio and video types.
 */
function media_is_supported_type($mime_type) {
  static $supported_types = NULL;

  if ($supported_types == NULL) {
    $supported_types = media_get_supported_types();
  }
  if (in_array($mime_type, array_keys($supported_types))) {
    return TRUE;
  }
  return FALSE;
}
/**
 * Returns an array of supported types. Builds array by calling getID3 and
 * asking which types are supported.
 */
function media_get_supported_types() {
  if ($supported_types = variable_get('media_supported_types', FALSE)) {
    // do nothing
  }
  else {
    media_include_library();
    $getID3 = new getID3;
    $supported_types = $getID3->GetFileFormatArray();
    foreach ($supported_types as $type) {
      $types[$type['mime_type']] = FALSE;
    }

    // Add some extra mime types which are supported but don't get recognized
    $types['video/x-ms-wmv'] = FALSE;
    $types['video/x-msvideo'] = FALSE;
    $types['video/wmv'] = FALSE;
    $types['video/avi'] = FALSE;
    //    $types['application/x-zip-compressed'] = FALSE;
    $types['application/vnd.rn-realmedia'] = FALSE;

    $supported_types = $types;
  }
  return $supported_types ? $supported_types : array();
}

/**
 * Plays a dynamically generated m3u file
 * 
 * TODO: rename $track to something more meaningful ($file? $files?)
 * 
 * TODO: document difference between this and media_stream_track
 */
function media_playlist_play($track) {
  if(is_array($track)){
    foreach ($track as $fid) {
      $file = media_get_file_by_id($fid);
      $url = file_create_url($file->filepath);     
      $m3u_data .= str_replace(' ', '%20', $url)."\r\n";
    }
    header("Pragma: no-cache"); // HTTP/1.0
    header("Cache-Control: private"); // HTTP/1.1
    header("Content-Type: audio/x-mpegurl", TRUE);
    header("Content-Length: ".strlen($m3u_data)."", TRUE);
    header("Content-Disposition:  attachment; filename=\"Playlist.m3u\"", TRUE);
    print $m3u_data;
    exit ();
  }
}

/**
 * Plays a dynamically generated mp3 file. See media_playlist_play 
 */
function media_stream_track($fid) {
  $file = media_get_file_by_id($fid);
  $url = file_create_url($file->filepath);
  $m3u_data = str_replace(' ', '%20', $url)."\r\n";
  $m3u_filename = preg_replace('/\..*$/', '.m3u', urlencode($file->filename));
  header("Expires: ".gmdate("D, d M Y H:i:s")." GMT", TRUE);
  header("Pragma: no-cache"); // HTTP/1.0
  header("Cache-Control: private"); // HTTP/1.1
  header("Content-Type: audio/x-mpegurl\n", TRUE);
  header("Content-Length: ".strlen($m3u_data)."\n", TRUE);
  header("Content-Disposition:  attachment; filename=\"$m3u_filename\"\n", TRUE);
  print $m3u_data;
  exit ();
}

/**
 * Renders the audio table on the media page
 */
function media_audio_table($enable_playlist = FALSE) {
  $keys = ($_POST['keys']) ? $_POST['keys'] : $_GET['keys'];
  
  $keys = mysql_escape_string($keys);

  $search_clause = ($keys) ? sprintf(" AND (f.filename LIKE '%%%s%%' OR name LIKE '%%%s%%' OR  id3_artist LIKE '%%%s%%' OR  id3_title LIKE '%%%s%%' OR  id3_album LIKE '%%%s%%' OR  id3_year LIKE '%%%s%%' OR  id3_genre LIKE '%%%s%%' OR  id3_track LIKE '%%%s%%' OR  id3_comment LIKE '%%%s%%' OR  fileformat LIKE '%%%s%%' OR  audio_bitrate LIKE '%%%s%%' OR  playtime_string LIKE '%%%s%%') ", $keys, $keys, $keys, $keys, $keys, $keys, $keys, $keys, $keys, $keys, $keys, $keys) : '' ;

  $media_type_clause = "(LEFT(filemime,5) = 'audio' OR filemime = 'application/vnd.rn-realmedia' OR RIGHT(f.filename,3) = 'ogg')";

  $table_attributes = array ();

  $sortable_columns['File name'] = array ('data' => 'File name', 'field' => 'filename', 'sort' => 'asc');
  $sortable_columns['Submitted by'] = array ('data' => 'Submitted by', 'field' => 'name');
  $sortable_columns['Artist'] = array ('data' => 'Artist', 'field' => 'id3_artist');
  $sortable_columns['Title'] = array ('data' => 'Title', 'field' => 'id3_title');
  $sortable_columns['Album'] = array ('data' => 'Album', 'field' => 'id3_album');
  $sortable_columns['Year'] = array ('data' => 'Year', 'field' => 'id3_year');
  $sortable_columns['Genre']= array ('data' =>'Genre', 'field' => 'id3_genre');
  $sortable_columns['Track'] = array ('data' => 'Track', 'field' => 'id3_track');
  $sortable_columns['Comment'] = array ('data' => 'Comment', 'field' => 'id3_comment');
  $sortable_columns['File format'] = array ('data' => 'File format', 'field' => 'fileformat');

  $header = array ('  ', 'actions', $sortable_columns['File name'], $sortable_columns['Submitted by'], $sortable_columns['Artist'], $sortable_columns['Title'], $sortable_columns['Album'], $sortable_columns['Year'],$sortable_columns['Genre'], $sortable_columns['Track'], $sortable_columns['Comment'], $sortable_columns['File format'], 'Bitrate', 'Playing time',);

  $rows = array (array ());

  $result = pager_query("SELECT f.fid, f.filename, f.filepath, name, av.id3_artist, av.id3_title, av.id3_album, av.id3_year, av.id3_genre, av.id3_track, av.id3_comment, av.fileformat, av.audio_bitrate, av.playtime_string FROM {audio_metadata} AS av,{node} AS n,{users} AS u,{files} AS f".
    " WHERE $media_type_clause $search_clause AND (av.fid = f.fid AND av.fid = f.fid AND f.nid = n.nid AND n.uid = u.uid)".tablesort_sql($header));

  while ($data_row = db_fetch_array($result)) {
    if ($enable_playlist) {
      $add_to_playlist_link = l(t('2pl'), $_GET['q'], NULL, $query = 'pl_add='.$data_row['fid']);
    }
    $stream_link = theme('stream_link', $data_row['fid']);
    $download_link = theme('download_link', $data_row['filepath']);
    $rows[] = array ($add_to_playlist_link, $stream_link.' '.$download_link, $data_row['filename'], $data_row['name'], $data_row['id3_artist'], $data_row['id3_title'], $data_row['id3_album'], $data_row['id3_year'], $data_row['id3_genre'], $data_row['id3_track'], $data_row['id3_comment'], $data_row['fileformat'], $data_row['audio_bitrate'], $data_row['playtime_string']);
  }

  $output = theme('pager'); //generates the links to view other pages
  $output .= '<br />';
  $output .= theme('table', $header, $rows, $table_attributes);
  $output .= '<br />';
  $output .= theme('pager'); //generates the links to view other pages

  return $output;
}                      //change 6 major update .

/**
 * Renders the video table on the media page
 */
function media_video_table($enable_playlist = FALSE) {

  $keys=($_POST['keys']) ? $_POST['keys'] : $_GET['keys'];
  
  $keys=mysql_escape_string($keys);
  
  $search_clause = ($keys) ? sprintf(" AND (f.filename LIKE '%%%s%%' OR name LIKE '%%%s%%' OR fileformat LIKE '%%%s%%' OR video_resolution_x LIKE '%%%s%%' OR video_resolution_y LIKE '%%%s%%' OR audio_bitrate LIKE '%%%s%%' OR playtime_string LIKE '%%%s%%') ", $keys, $keys, $keys, $keys, $keys, $keys, $keys) : '' ;
  
//  $search_clause = ($keys) ? " AND (f.filename LIKE '%$keys%' OR name LIKE '%$keys%' OR fileformat LIKE '%$keys%' OR video_resolution_x LIKE '%$keys%' OR video_resolution_y LIKE '%$keys%' OR audio_bitrate LIKE '%$keys%' OR playtime_string LIKE '%$keys%') " : '';

  $media_type_clause = "(LEFT(filemime,5) = 'video' OR filemime = 'application/x-shockwave-flash')";

  $table_attributes = array ();

  $sortable_columns[t('File name')] = array ('data' => t('File name'), 'field' => 'filename', 'sort' => 'asc');
  $sortable_columns[t('Submitted by')] = array ('data' => t('Submitted by'), 'field' => 'name');
  $sortable_columns[t('File format')] = array ('data' => 'File format', 'field' => 'fileformat');

  $header = array ('  ', t('actions'), $sortable_columns[t('File name')], $sortable_columns[t('Submitted by')], $sortable_columns[t('File format')], t('display size'), t('Bitrate'), t('Playing time'),);

  $rows = array (array ());

  $result = pager_query("SELECT f.fid, f.filename, name, fileformat, video_resolution_x, video_resolution_y, video_bitrate, playtime_string FROM {video_metadata} AS av,{files} AS f,{node} AS n,{users} AS u WHERE $media_type_clause $search_clause AND (av.fid = f.fid AND av.fid = f.fid AND f.nid = n.nid AND n.uid = u.uid)".tablesort_sql($header));

  while ($data_row = db_fetch_array($result)) {
    if ($enable_playlist) {
      $add_to_playlist_link = l(t('2pl'), $_GET['q'], NULL, $query = 'pl_add='.$data_row['fid']);
    }
    $stream_link = (user_access('stream media')) ? l(t('stream'), 'media', NULL, $query = 'stream='.$data_row['fid']) : '';
    $file = media_get_file_by_id($fid);
     // TODO: replace $link with themed link
    $link = media_get_link($file);
    // TODO: replace $downloa_link with themed link
    $download_link = (user_access('download media')) ? $link : '';
    $rows[] = array ($add_to_playlist_link, $stream_link.' '.$download_link, $data_row['filename'], $data_row['name'], $data_row['fileformat'], $data_row['video_resolution_x'].' x '.$data_row['video_resolution_y'], $data_row['video_bitrate'], $data_row['playtime_string']);
  }

  $output = theme('pager'); //generates the links to view other pages
  $output .= '<br />';
  $output .= theme('table', $header, $rows, $table_attributes);
  $output .= '<br />';
  $output .= theme('pager'); //generates the links to view other pages

  return $output; //change 7
}

// TODO: after completing TODOs in media_video_table, remove this function
function media_get_link($file) {
  $link = '<a href="'.  file_create_url($file->filepath) . '">'. $file->filename .'</a>';
  return $link;  
}

/**
 * Helper method. Loads a file object from $fid.
 */
function media_get_file_by_id($fid) {
  $file = db_fetch_object(db_query("SELECT * from {files} WHERE fid = %d", $fid));
  return $file;
}

/**
 * TODO: documentation
 */
function media_array_to_columns($prefix = NULL, $array) {
  foreach ($array as $name => $value) {
    if (is_array($value)) {
      if ($prefix) {
        $new_prefix = $prefix.'_'.$name;
      } else {
        $new_prefix = $name;
      }
      $result = array_merge((array) $result, media_array_to_columns($new_prefix, $value));
    } else {
      if ($prefix) {
        $result[$prefix.'_'.$name] = $value;
      } else {
        $result[$name] = $value;
      }
    }
  }
  return $result ;   
}

/**
 * TODO: documentation
 */
function media_playlist_sort_init($source){   
  $target = array();
  if (is_array($source)) {
    foreach ($source as $key => $value) {
      if ($value['next_fid'] == -1) {
        array_unshift($target, $value);
        unset($source[$key]);
        break;  
      } 
    }
    
    media_playlist_sort($source, $target);
  }
  return $target ;  
}

/**
 * TODO: documentation. compare to media_playlist_sort_init
 */
function media_playlist_sort (&$source, &$target){ 
  if (!empty($source)){
    foreach ($source as $key => $value){
      if ($value['next_fid']==$target[0]['fid']) {
        array_unshift($target, $value);
        unset($source[$key]);
        break;
      }
    }
    
  }  
  else {
    return;
  }
  media_playlist_sort($source, $target);

}

/**
 * Override this in your theme to control how the download link is rendered
 */
function theme_download_link($path) {
   $link = '<a href="'.  file_create_url($path) . '">'. t('download') .'</a>';
   return (user_access('download media')) ? $link : '';
}

/**
 * Override this in your theme to control how the streaming link is rendered.
 */
function theme_stream_link($fid) {
  return (user_access('stream media')) ? l(t('stream'), 'media', NULL, $query = 'stream='.$fid) : '';
}
?>
<?php


/**
 * @file 
 * Resource API for Drupal, a replacement for files.
 * 
 * The Resource API superceeds Drupal's file api, providing an interface to 
 * manage Resources identified by a URL.
 *
 * There are two base classes, Resource and ResourceScheme, that constitue the ResourceAPI. 
 * The Resource class provides a high level interaction with resources including event hooks,
 * DB synchronization, and support methods including, but not limited, to url generation and
 * mime identification. The ResourceScheme is a user defined stream wrapper for PHP. 
 *
 * In most cases each class extending Resource will have a complimentary ResourceScheme
 * class, and will share configuration options and settings.
 *
 */

/**
 * Implementation of hook_boot
 * 
 * Registers core stream handlers for public and private files.
 */

function resource_boot() {
  $manager = ResourceSchemeManager::singleton();
  $manager->register('public',   'ResourceSchemePublic',  'ResourcePublic');
  $manager->register('private',  'ResourceSchemePrivate', 'ResourcePrivate');
}

function resource_init() {
  $manager = ResourceSchemeManager::singleton();
  resource_debug(print_r($manager->wrappers(),1));

}

function resource_perm() {
  return array(
    'administer resources' => array(
      'title' => 'Administer resources',
      'Description' => 'Administer settings for resources and stream handlers.'
    ),
  );  
}

function resource_menu() {
  $items = array();

  // menu items that are basically just menu blocks
  $items['admin/settings/resources'] = array(
    'title' => 'Resource configuration',
    'description' => 'Configure Resource and stream handler settings.',
    'page callback' => 'resource_settings_overview',
    'access arguments' => array('access administration pages'),
  );

  $items['admin/settings/resource/public'] = array(
    'title' => 'Public File (public://) settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('resource_settings_public_form'),
    'access arguments' => array('administer resources')
  );
  $items['admin/settings/resource/private'] = array(
    'title' => 'Private File (private://) settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('resource_settings_private_form'),
    'access arguments' => array('administer resources')
  );
  return $items; 
}

/**
 * Menu callback; displays a module's settings page.
 */
function resource_settings_overview() {
  // Check database setup if necessary
  if (function_exists('db_check_setup') && empty($_POST)) {
    db_check_setup();
  }

  $item = menu_get_item('admin/settings/stream');
  $content = system_admin_menu_block($item);

  $output = theme('admin_block_content', $content);

  return $output;
}

function resource_settings_public_form() {
  $form = array();
  $form['stream_public_path'] = array(
    '#type' => 'textfield',
    '#title' => t('public:// file path'),
    '#default_value' => variable_get('stream_public_path', 'sites/default/files'),
    '#maxlength' => 255,
    '#description' => t('The path where public:// files will be stored. This directory must exist and be writable by Drupal. If the download method is set to public, this directory must be relative to the Drupal installation directory and be accessible over the web. If the download method is set to private, this directory should not be accessible over the web. Changing this location will modify all download paths and may cause unexpected problems on an existing site.'),
    '#after_build' => array('system_check_directory')
  );
  return system_settings_form($form);
}

function resource_settings_private_form() {
  $form = array();
  $form['stream_private_path'] = array(
    '#type' => 'textfield',
    '#title' => t('private:// file path'),
    '#default_value' => variable_get('stream_private_path', 'sites/default/files-private'),
    '#maxlength' => 255,
    '#description' => t('The path where public:// files will be stored. This directory must exist and be writable by Drupal. If the download method is set to public, this directory must be relative to the Drupal installation directory and be accessible over the web. If the download method is set to private, this directory should not be accessible over the web. Changing this location will modify all download paths and may cause unexpected problems on an existing site.'),
    '#after_build' => array('system_check_directory')
  );

  return system_settings_form($form);
}

/**
 * Resource API
 */

/** 
 * Debug Logging function.
 */
function resource_debug($message) {
  if (TRUE) watchdog('stream', $message, array(), WATCHDOG_DEBUG);
}

/**
 * The ResourceSchemeManager provides a class for managing and querying
 * user defined stream wrappers in PHP.
 */

class ResourceSchemeManager {
  // stream wrapper registry
  static private $wrappers = array();

  // private constructor to enforce singleton.
  private function __construct() { }

  /**
   * Load the singleton instance of the ResourceSchemeManager.
   * @return object:ResourceSchemeManager
   */
  public static function singleton() {
    static $instance = NULL;
    if (is_null($instance)) {
      $instance = new ResourceSchemeManager();
    }
    return $instance;
  }

  /**
   * Register a class to handle a scheme.
   * @param string $scheme URI scheme.
   * @param string $class  classname for the stream wrapper.
   * @return bool result of stream_wrapper_register 
   * @see: http://us3.php.net/manual/en/function.stream-wrapper-register.php
   */
  function register($scheme, $ResourceSchemeClass, $ResourceClass) {
    resource_debug("ResourceSchemeManager:: register($scheme, $ResourceSchemeClass, $ResourceClass)");
    self::$wrappers[$scheme]['ResourceSchemeClass'] = $ResourceSchemeClass;
    self::$wrappers[$scheme]['ResourceClass'] = $ResourceClass;
    return stream_wrapper_register($scheme, $ResourceSchemeClass);
  }

  function unregister($scheme) {
    if (stream_wrapper_unregister($scheme)) {
      unset(self::$wrappers[$scheme]);
      return TRUE;
    }
    return FALSE;
  }

  /**
   * Return the streamwrapper classname for a given scheme.
   * @param string $scheme stream scheme.
   * @return mixed string is a scheme has a registered handler or FALSE.
   */
  function ResourceSchemeClass($scheme) {
    if (empty(self::$wrappers[$scheme]['ResourceResourceClass'])) {
      return FALSE;
    }
    return self::$wrappers[$scheme];
  }

  /**
   * Return the stream class name for a given scheme.
   * @param string $scheme stream scheme.
   * @return mixed string is a scheme has a registered handler or FALSE.
   */
  function ResourceClass($scheme) {
    if (empty(self::$wrappers[$scheme]['ResourceClass'])) {
      return FALSE;
    }
    return self::$wrappers[$scheme];
  }


  /**
   * Return the ResourceSchemeManagers wrapper registry.
   */ 
  function wrappers() {
    return self::$wrappers;
  }
}

/**
 * An asbtract class for custom ResourceSchemes to extend.
 *
 * This class provides a complete stream wrapper implementation. It passes
 * incoming  URL's through an interpolation method then recursively calls
 * the invoking PHP filesystem function.
 *
 * ResourceScheme implementations need to override at least the interpolate_url
 * method to rewrite the URL before is it passed back into the calling function.
 * 
 */
class ResourceScheme {
  private $handle;

  // parse the generic part of the URL following scheme. 
  function interpolate_url($url) { 
    return '';
  }

  /**
   * Support for fopen(), file_get_contents(), file_put_contents() etc.
   *
   * @param $path
   *   A string containing the path to the file to open.
   * @param $mode
   *   The file mode ("r", "wb" etc.).
   * @param $options
   *   A bit mask of STREAM_USE_PATH and STREAM_REPORT_ERRORS.
   * @param &$opened_path
   *   A string containing the path actually opened.
   * @return
   *  TRUE if file was opened successfully.
   */
  public function stream_open($url, $mode, $options, &$opened_url) {
    resource_debug('stream open begin');
    $url = $this->interpolate_url($url);
    resource_debug('stream open end');
    $this->handle = ($options & STREAM_REPORT_ERRORS) ? fopen($url, $mode) : @fopen($url, $mode);
    $opened_url =  ((bool)$this->handle && $options & STREAM_USE_PATH) ? $url : $opened_url;
    return (bool)$this->handle;
  }

  // Undocumented PHP stream wrapper method.
  function stream_lock($operation) {
    if (in_array($operation, array(LOCK_SH, LOCK_EX, LOCK_UN, LOCK_NB))) {
      return flock($this->handle, $operation);
    }
    return TRUE;
  }

  /**
   * Support for fread(), file_get_contents() etc.
   *
   * @param $count
   *    Maximum number of bytes to be read.
   * @return
   *  The string that was read, or FALSE in case of an error.
   */
  public function stream_read($count) {
    return fread($this->handle, $count);
  }

  /**
   * Support for fwrite(), file_put_contents() etc.
   *
   * @param $data
   *   The string to be written.
   * @return
   *   The number of bytes written.
   */
  public function stream_write($data) {
    return fwrite($this->handle, $data);
  }

  /**
   * Support for feof().
   *
   * @return
   *   TRUE if end-of-file has been reached.
   */
  public function stream_eof() {
    return feof($this->handle);
  }

  /**
   * Support for fseek().
   * 
   * @param $offset
   *   The byte offset to got to.
   * @param $whence
   *   SEEK_SET, SEEK_CUR, or SEEK_END.
   * @return
   *   TRUE on success
   */
  public function stream_seek($offset, $whence) {
    return fseek($this->handle, $offset, $whence);
  }

  /**
   * Support for fflush().
   *
   * @return
   *   TRUE if data was successfully stored (or there was no data to store).
   */
  public function stream_flush() {
    return fflush($this->handle);
  }

  /**
   * Support for ftell().
   *
   * @return
   *   The current offset in bytes from the beginning of file.
   */
  public function stream_tell() {
    return ftell($this->handle);
  }

  /**
   * Support for fstat().
   *
   * @return
   *   An array with file status, or FALSE in case of an error - see fstat()
   *   for a description of this array.
   */
  public function stream_stat() {
    return fstat($this->handle);
  }

  /**
   * Support for fclose().
   *
   * @return
   *   TRUE if stream was successfully closed.
   */
  public function stream_close() {
    return fclose($this->handle);
  }

  /**
   * Support for unlink().
   *
   * @param $url
   *   A string containing the url to the resource to delete.
   * @return
   *   TRUE if resource was successfully deleted.
   */
  public function unlink($url) {
    return unlink($this->interpolate_url($url));
  }

  /**
   * Support for rename().
   *
   * @param $fromUrl, 
   *   The url to the file to rename.
   * @param $toUrl
   *   The new url for file.
   *
   * @return
   *   TRUE if file was successfully renamed.
   */
  public function rename($fromUrl, $toUrl) {
    return rename($this->interpolate_url($fromUrl), $this->interpolate_url($toUrl));
  }

  /**
   * Support for mkdir().
   *
   * @param $url
   *   A string containing the url to the directory to create.
   * @param $mode
   *   Permission flags - see mkdir().
   * @param $options
   *   A bit mask of STREAM_REPORT_ERRORS and STREAM_MKDIR_RECURSIVE.
   * @return
   *   TRUE if directory was successfully created.
   */
  public function mkdir($url, $mode, $options) {
    $recursive = (bool)($options & STREAM_MKDIR_RECURSIVE);
    if ($options & STREAM_REPORT_ERRORS) {
      return mkdir($this->interpolate_url($url), $mode, $recursive);
    }
    else {
      return @mkdir($this->interpolate_url($url), $mode, $recursive);
    }
  }

  /**
   * Support for rmdir().
   *
   * @param $url
   *   A string containing the url to the directory to delete.
   * @param $options
   *   A bit mask of STREAM_REPORT_ERRORS.
   * @return
   *   TRUE if directory was successfully removed.
   */
  public function rmdir($url, $options) {
    if ($options & STREAM_REPORT_ERRORS) {
      return rmdir($this->interpolate_url($url));
    }
    else {
      return @rmdir($this->interpolate_url($url));
    }
  }

  /**
   * Support for stat().
   *
   * @param $url
   *   A string containing the url to get information about.
   * @param $flags
   *   A bit mask of STREAM_URL_STAT_LINK and STREAM_URL_STAT_QUIET.
   * @return
   *   An array with file status, or FALSE in case of an error - see fstat()
   *   for a description of this array.
   */
  public function url_stat($url, $flags) {
    return ($flags & STREAM_URL_STAT_QUIET) ? @stat($this->interpolate_url($url)) : stat($this->interpolate_url($url));
  }

  /**
   * Support for opendir().
   *
   * @param $url
   *   A string containing the url to the directory to open.
   * @param $options
   *   Unknown (parameter is not documented in PHP Manual).
   * @return
   *   TRUE on success.
   */
  public function dir_opendir($url, $options) {
    $this->handle = opendir($this->interpolate_url($url));
    return (bool)$this->handle;
  }

  /**
   * Support for readdir().
   *
   * @return
   *   The next filename, or FALSE if there are no more files in the directory.
   */
  public function dir_readdir() {
    return readdir($this->handle);
  }

  /**
   * Support for rewinddir().
   *
   * @return
   *   TRUE on success.
   */
  public function dir_rewinddir() {
    return rewinddir($this->handle);
  }

  /**
   * Support for closedir().
   *
   * @return
   *   TRUE on success.
   */
  public function dir_closedir() {
    return closedir($this->handle);
  }
}

/**
 * public:// stream wrapper class.
 */
class ResourceSchemePublic extends ResourceScheme {

  // A handle to the file opened by stream_open().
  private $pathkey = 'stream_public_path';
  private $pathdefault = 'sites/default/files';

  /**
   * interpolate the url for a public stream into a
   * real stream or path.
   */
  function interpolate_url($url) {
    resource_debug($url);
    $basepath = variable_get($this->pathkey, $this->pathdefault);
    
    // just in case stream_public_path is s3://, ftp://, etc. Don't call PHP's
    // realpath().
    if (parse_url($basepath, PHP_URL_SCHEME)) {
      $path =  $basepath . parse_url($url, PHP_URL_PATH);;
    }
    else {
    // interpolate relative paths for basepath, and strip relative paths from 
    // url path.
      $path = realpath($basepath) . str_replace('/..','', parse_url($url, PHP_URL_PATH));
    }
    resource_debug($path);
    return $path;
  }
}

/**
 * private:// stream wrapper class.
 */
class ResourceSchemePrivate extends ResourceSchemePublic {
  private $pathkey = 'stream_private_path';
  private $pathdefault = 'sites/default/files-private';
}



/**
 * Base Resource class. 
 *
 * The drupal_file class represents a physical file stored in Drupal's
 * 'File System Path'. It is important to understand that copy, move, 
 * delete, etc method affect both the the physical file the object
 * represents and the database record for the file. 
 *
 * Example Factory Usage:
 *   
 *   $factory = new Resource();
 *   $file = $factory->load_id(87);
 *   $another = $file->load_path('images/logo.png');
 *
 *   $file = Resource::load_id(24);
 *
 *   $yet_another = $file->load('path', 'uploads/myfile.pdf');
 *
 * 
 *   if ($yet_another->delete()) unset($yet_another);
 *
 */ 

class Resource {

  // @see drupal_file::load()
  protected static $files = array();

  public $fid = 0;
  public $uid = 1;
  public $filename = '';
  public $filepath = '';
  public $filemime = 'application/octet-stream';
  public $filesize = 0;  
  public $status = 0;
  public $timestamp = 0;

  /**
   * drupal_file constructor.
   *
   * @param object $file (optional) stdClass object to initialize self with.
   */
  function __construct($file = FALSE) {
    if (!$file || !is_object($file)) return;
    // assign all initialized properties to self.
    foreach ($file as $key => $value) {
      $this->$key = $value;
    }
  }

  function _exists_rename($destination) {
    if (file_exists($destination)) { 
      $parts = parse_url($destination);
      $streamdir = $parts['scheme'] . dirname($parts['path']);
      $basename = basename($parts['path']);

      // Destination file already exists, generate an alternative.
      $pos = strrpos($basename, '.');
      if ($pos !== FALSE) {
        $name = substr($basename, 0, $pos);
        $ext = substr($basename, $pos);
      }
      else {
        $name = $basename;
        $ext = '';
      }
  
      $counter = 0;
      do {
        $destination = $directory . '/' . $name . '_' . $counter++ . $ext;
      } while (file_exists($destination));
    }
  
    return $destination;
  }

  /**
   * Create a copy a drupal_file.
   *
   * @param  string $destination (optional) @see file_copy.
   * @param int $replace (optional) @see file_destination
   * @return object|bool  drupal_file if the copy is successful, or FALSE
   * @see file_copy()
   */
  function copy($destination, $replace = FILE_EXISTS_RENAME) {
    if (file_exists($destination)) {
      if ($replace & FILE_EXISTS_ERROR) {
        return FALSE;
      }
      if ($replace & FILE_EXISTS_RENAME) {
        $destination = $this->_exists_rename($destination); 
      }
    }
       
    if (copy($this->filepath, $destination, $replace)) {
      $file = clone $this;
      $file->fid      = null;
      $file->filename = basename($result);
      $file->filepath = $destination;
      if ($file->save()) {
        module_invoke_all('file_copy', $this, $file);
        return $file;
      }
    }
    return FALSE; 
  }


  /**
   * Delete a file and its database record.
   *
   * @param $force
   *   Boolean indicating that the file should be deleted even if
   *   hook_file_references() reports that the file is in use.
   * @return mixed 
   *   TRUE for success, array for reference count, or FALSE in the event
   *   of an error.
   *
   * @see hook_file_references()
   */
  function delete($force = FALSE) {
    // If any module returns a value from the reference hook, the 
    // file will not be deleted from Drupal, but file_delete will
    // return a populated array that tests as TRUE.
    if (!$force && ($references = module_invoke_all('file_references', $this))) {
      return $references;
    }

    // Let other modules clean up on delete.
    module_invoke_all('file_delete', $this);
 
    // Make sure the file is deleted before removing its row from the 
    // database, so UIs can still find the file in the database.
    if (unlink($this->filepath)) {
      db_query('DELETE FROM {files} WHERE fid = %d', $this->fid);
      // remove internally used static cache entries.
      $this->reset_cache('fid::'. $this->fid);
      $this->reset_cache('filepath::'. $this->filepath);
      return TRUE;
    }
    return FALSE;
  }

  /**
   * Return the first matching file in the files table. This is a simple single
   * object loader it in combination with the static $files variable allows all
   * drupal file objects to also act as factories and share the same static cache.
   *
   * @param string key (required) database column to use in where condition.
   * @param int|string value (required) the value of the column to use in the where condition.
   * @return object|bool A Drupal file object or FALSE if a file was not found.
   * @see drupal_file::load(), drupal_file::load_path()
   */
  final function _load($column, $value) {
    // set a cache id based on key and value so we can statically cache 
    // all simple loads.
    $cid = $column . '::' . $value; 
    if (empty(self::$files[$cid])) {
      $file = db_fetch_object(db_query('SELECT f.* FROM {files} f WHERE f.%s = %d', $column, $value));
      $scheme = parse_url($file, PHP_URL_PATH);
      $class = ResourceSchemeManager::get_classname($scheme);
      $file = new $class($file);
    }
    module_invoke_all('file_load', $file);
    self::$files[$cid] = $file; 
    // Files are not cloned, because there is in fact only one.
    return self::$files[$cid];
  }
 
  /**
   * Load a file object from the database by id.
   *
   * @param int   $id     A file id. (required)
   * @return object|bool A Drupal file object or FALSE if a file was not found.
   * @see: drupal_file::load()
   */
  final function load_id($id) {
    return $this->_load('fid', $id);
  }

  /**
   * Load a file object from the database by path.
   *
   * @param string  $path   A path to a file. (required)
   * @return object|bool A Drupal file object or FALSE if a file was not found.
   * @see: drupal_file::load()
   */
  final function load_path($path) {
    return $this->_load('filepath', $path);
  }

  /**
   * Move a drupal_file.
   *
   * @param  string $destination (optional) @see file_copy.
   * @param int $replace (optional) @see file_destination
   * @return bool 
   * @see file_copy()
   */
  function move($destination, $replace = FILE_EXISTS_RENAME) {
    if (file_exists($destination)) {
      if ($replace & FILE_EXISTS_ERROR) {
        return FALSE;
      }
      if ($replace & FILE_EXISTS_RENAME) {
        $destination = $this->_exists_rename($destination); 
      }
    }
 
    if (rename($this->filepath, $destination)) {
      $orig = clone $this;
      $this->filename = basename($destination);
      $this->filepath = $result;
      if ($this->save()) {
        module_invoke_all('file_move', $this, $orig);
        return TRUE;
      }
    }
    return FALSE;
  }

  /**
   * Reset the shared static cache.
   */
  public function reset_cache($cid = FALSE) {
    // no cache id, reset the entire cache.
    if (!$cid) {
      self::$files = array();
    }
    elseif (isset(self::$files[$cid])) {
      unset(self::$files[$cid]);
    }
  }

  /**
   * Save the current state of a drupal_file in the database.
   * If the file->fid is empty a new database record will be added. 
   *
   * @return bool TRUE if save succeeded, FALSE if save failed.
   */
  function save() {
    $this->timestamp = time();
    $this->filesize = filesize($this->filepath);
  
    if (empty($this->fid)) {
      $result = drupal_write_record('files', $this);
      module_invoke_all('file_insert', $this);
    }
    else {
      $result = drupal_write_record('files', $this, 'fid');
      module_invoke_all('file_update', $this);
    }
    return $result;
  }

  /**
   * Mark a file as permanent.
   *
   * @return bool 
   */
  function set_status($bitmask = NULL) {
    if (is_null($bitmask)) {
      return $file->status;
    }
    elseif (db_query('UPDATE {files} SET status=%d', $bitmask, $this->fid)) {
      $this->status = $status;
      module_invoke_all('file_set_status', $this, $status);
      return TRUE;
    }
    return FALSE;
  }

  /**
   * Create a URL to the file.
   */
  function url() {
    return '';
  }
}

class ResourcePublic extends Resource {
  function url() { }  
  function mime() { } 
}

class ResourcePrivate extends ResourcePublic {
  function url() { }
}

class ResourceUpload extends Resource {
  public $source = '';
  public $errors;

  function save() {
    // validate if not already validated, error is validation didn't pass.
    if (!$this->validate()) {
      return FALSE;
    }
    // rename the file to its original name.
    parent::save();
  }

  function validate($validators = array()) {
    if (!isset($this->errors)) {
      // Default validation for all uploads.
      $validators['file_validate_name_length'] = array();
    
      $this->errors = array();
      foreach ($validators as $function => $args) {
        array_unshift($args, $file);
        $errors = array_merge($errors, call_user_func_array($function, $args));
      }
    }
    return !empty($this->errors);
  }

  function errors() {
    return $this->errors;
  }

  function move($dest) {
    // validate if not already validated, error is validation didn't pass.
    if (!$this->fid && !$this->save()) {
      return FALSE;
    }
    // for upload files we changed the filename in the path to a junk string...
     
  }

  /**
   * Saves a file upload to a temporary location
   *
   * The file will be added to the files table as a temporary file. Temporary
   * files are periodically cleaned. To make the file permanent file call
   * it's set_permanent() method.
   *
   * @param $source
   *   A string specifying the name of the upload field to save.
   * @param $validators
   *   An optional, associative array of callback functions used to validate the
   *   file. The keys are function names and the values arrays of callback
   *   parameters which will be passed in after the user and file objects. The
   *   functions should return an array of error messages, an empty array
   *   indicates that the file passed validation. The functions will be called in
   *   the order specified.
   * @param $destination
   *   A string containing the directory $source should be copied to. If this is
   *   not provided or is not writable, the temporary directory will be used.
   * @param $replace
   *   A boolean indicating whether an existing file of the same name in the
   *   destination directory should overwritten. A FALSE value will generate a
   *   new, unique filename in the destination directory.
   * @return
   *   An object containing the file information, or FALSE in the event of an 
   *   error.
   */

  static function save_upload($source) {
    // check and see if there were any errors.
    if (drupal_file_upload::upload_error($source)) {
      return FALSE;
    }

    // Begin building file object.
    $file = new stdClass();
    $file->source   = $source;
    $file->uid      = $user->uid;
    $file->filename = basename($_FILES['files']['name'][$source]);
    // create a tmp path to use until the file is save to a final location else where.
    // we just use a random string to defang the file for processing in tmp.
    $file->filepath = file_destination(uniqid(),  file_directory_temp(), FALSE);
    $file->filemime = $_FILES['files']['type'][$source];
    $file->filesize = $_FILES['files']['size'][$source];


    // Move uploaded files from PHP's upload_tmp_dir to Drupal's temporary 
    // directory. This overcomes open_basedir restrictions for future file
    // operations.
    if (!move_uploaded_file($_FILES['files']['tmp_name'][$source], $file->filepath)) {
      form_set_error($source, t('File upload error. Could not move uploaded file.'));
      watchdog('file api', 'Upload error. Could not move uploaded file %file to destination %destination.', array('%file' => $file->filename, '%destination' => $file->filepath));
      return FALSE;
    }
    return $file;
  }

  function upload_error($errno) {
    // If no file was uploaded there is an error. :)
    if (empty($_FILES['files']['tmp_name'][$source]) || !is_uploaded_file($_FILES['files']['tmp_name'][$source])) {
      return t('No file uploaded');
    }


    // @see http://php.net/manual/en/features.file-upload.errors.php
    switch ($_FILES['files']['error'][$source]) {
      case UPLOAD_ERR_OK:
        return FALSE;

      case UPLOAD_ERR_INI_SIZE:
      case UPLOAD_ERR_FORM_SIZE:
        return t('The file %file could not be saved, because it exceeds %maxsize, the maximum allowed size for uploads.', array('%file' => $source, '%maxsize' => format_size(file_upload_max_size())));

      case UPLOAD_ERR_PARTIAL:
      case UPLOAD_ERR_NO_FILE:
        return t('The file %file could not be saved, because the upload did not complete.', array('%file' => $source));

      case UPLOAD_ERR_NO_TMP_DIR:
        return t('The file %file could not be saved, because the PHP upload_tmp_dir does not exist.', array('%file' => $source));
          
      case UPLOAD_ERR_CANT_WRITE:
        return t('The file %file could not be saved, because the file could not be written to the disk.', array('%file' => $source));

      case UPLOAD_ERR_EXTENSION:
        return t('The file %file could not be saved, because the upload was stopped by a php extension.', array('%file' => $source));

      // Unknown error
      default:
        return t('The file %file could not be saved. An unknown error has occurred.', array('%file' => $source));
    }
  } 

  // Use static load as the entry point to keep the API interface
  // consistent.    
  function load($source) {
    if (isset(self::$files[$source])) return self::$files[$source];

    // attempt to save the upload.
    if ($file = self::save_upload($source)) {
      return new ResourcePublic($file);
    }
  }

}
  


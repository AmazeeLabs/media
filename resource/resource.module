<?php


/**
 * @file 
 * Resource API for Drupal, a replacement for files.
 * 
 * The Resource API superceeds Drupal's file api, providing an interface to 
 * manage Resources identified by a URL.
 *
 * There are two base classes, Resource and ResourceScheme, that constitue the ResourceAPI. 
 * The Resource class provides a high level interaction with resources including event hooks,
 * DB synchronization, and support methods including, but not limited, to url generation and
 * mime identification. The ResourceScheme is a user defined stream wrapper for PHP. 
 *
 * In most cases each class extending Resource will have a complimentary ResourceScheme
 * class, and will share configuration options and settings.
 *
 */

/**
 * Implementation of hook_boot
 * 
 * Registers core stream handlers for public and private files.
 */

function resource_boot() {
  $manager = DrupalResourceStreamWrapperManager::singleton();
  $manager->register('public',   'DrupalStreamWrapperPublic',  'DrupalResourcePublic');
  $manager->register('private',  'DrupalStreamWrapperPrivate', 'DrupalResourcePrivate');
}

function resource_perm() {
  return array(
    'administer resources' => array(
      'title' => 'Administer resources',
      'Description' => 'Administer settings for resources and stream handlers.'
    ),
  );  
}

function resource_menu() {
  $items = array();

  // menu items that are basically just menu blocks
  $items['admin/settings/resources'] = array(
    'title' => 'Resource configuration',
    'description' => 'Configure Resource and stream handler settings.',
    'page callback' => 'resource_settings_overview',
    'access arguments' => array('access administration pages'),
  );

  $items['admin/settings/resource/public'] = array(
    'title' => 'Public File (public://) settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('resource_settings_public_form'),
    'access arguments' => array('administer resources')
  );
  $items['admin/settings/resource/private'] = array(
    'title' => 'Private File (private://) settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('resource_settings_private_form'),
    'access arguments' => array('administer resources')
  );
  return $items; 
}

/**
 * Menu callback; displays a module's settings page.
 */
function resource_settings_overview() {
  // Check database setup if necessary
  if (function_exists('db_check_setup') && empty($_POST)) {
    db_check_setup();
  }

  $item = menu_get_item('admin/settings/stream');
  $content = system_admin_menu_block($item);

  $output = theme('admin_block_content', $content);

  return $output;
}

function resource_settings_public_form() {
  $form = array();
  $form['stream_public_path'] = array(
    '#type' => 'textfield',
    '#title' => t('public:// file path'),
    '#default_value' => variable_get('stream_public_path', 'sites/default/files'),
    '#maxlength' => 255,
    '#description' => t('The path where public:// files will be stored. This directory must exist and be writable by Drupal. If the download method is set to public, this directory must be relative to the Drupal installation directory and be accessible over the web. If the download method is set to private, this directory should not be accessible over the web. Changing this location will modify all download paths and may cause unexpected problems on an existing site.'),
    '#after_build' => array('system_check_directory')
  );
  return system_settings_form($form);
}

function resource_settings_private_form() {
  $form = array();
  $form['stream_private_path'] = array(
    '#type' => 'textfield',
    '#title' => t('private:// file path'),
    '#default_value' => variable_get('stream_private_path', 'sites/default/files-private'),
    '#maxlength' => 255,
    '#description' => t('The path where public:// files will be stored. This directory must exist and be writable by Drupal. If the download method is set to public, this directory must be relative to the Drupal installation directory and be accessible over the web. If the download method is set to private, this directory should not be accessible over the web. Changing this location will modify all download paths and may cause unexpected problems on an existing site.'),
    '#after_build' => array('system_check_directory')
  );

  return system_settings_form($form);
}

/**
 * Resource API
 */

/** 
 * Debug Logging function.
 */
function resource_debug($message) {
  if (TRUE) watchdog('stream', $message, array(), WATCHDOG_DEBUG);
}

/**
 * Base Resource class. 
 *
 * The drupal_file class represents a physical file stored in Drupal's
 * 'File System Path'. It is important to understand that copy, move, 
 * delete, etc method affect both the the physical file the object
 * represents and the database record for the file. 
 *
 * Example Factory Usage:
 *   
 *   $factory = new Resource();
 *   $file = $factory->load_id(87);
 *   $another = $file->load_path('images/logo.png');
 *
 *   $file = Resource::load_id(24);
 *
 *   $yet_another = $file->load('path', 'uploads/myfile.pdf');
 *
 * 
 *   if ($yet_another->delete()) unset($yet_another);
 *
 */ 

class Resource {

  // @see drupal_file::load()
  protected static $files = array();

  public $fid = 0;
  public $uid = 1;
  public $filename = '';
  public $filepath = '';
  public $filemime = 'application/octet-stream';
  public $filesize = 0;  
  public $status = 0;
  public $timestamp = 0;

  /**
   * drupal_file constructor.
   *
   * @param object $file (optional) stdClass object to initialize self with.
   */
  function __construct($file = FALSE) {
    if (!$file || !is_object($file)) return;
    // assign all initialized properties to self.
    foreach ($file as $key => $value) {
      $this->$key = $value;
    }
  }

  function _exists_rename($destination) {
    if (file_exists($destination)) { 
      $parts = parse_url($destination);
      $streamdir = $parts['scheme'] . dirname($parts['path']);
      $basename = basename($parts['path']);

      // Destination file already exists, generate an alternative.
      $pos = strrpos($basename, '.');
      if ($pos !== FALSE) {
        $name = substr($basename, 0, $pos);
        $ext = substr($basename, $pos);
      }
      else {
        $name = $basename;
        $ext = '';
      }
  
      $counter = 0;
      do {
        $destination = $directory . '/' . $name . '_' . $counter++ . $ext;
      } while (file_exists($destination));
    }
  
    return $destination;
  }

  /**
   * Create a copy a drupal_file.
   *
   * @param  string $destination (optional) @see file_copy.
   * @param int $replace (optional) @see file_destination
   * @return object|bool  drupal_file if the copy is successful, or FALSE
   * @see file_copy()
   */
  function copy($destination, $replace = FILE_EXISTS_RENAME) {
    if (file_exists($destination)) {
      if ($replace & FILE_EXISTS_ERROR) {
        return FALSE;
      }
      if ($replace & FILE_EXISTS_RENAME) {
        $destination = $this->_exists_rename($destination); 
      }
    }
       
    if (copy($this->filepath, $destination, $replace)) {
      $file = clone $this;
      $file->fid      = null;
      $file->filename = basename($result);
      $file->filepath = $destination;
      if ($file->save()) {
        module_invoke_all('file_copy', $this, $file);
        return $file;
      }
    }
    return FALSE; 
  }


  /**
   * Delete a file and its database record.
   *
   * @param $force
   *   Boolean indicating that the file should be deleted even if
   *   hook_file_references() reports that the file is in use.
   * @return mixed 
   *   TRUE for success, array for reference count, or FALSE in the event
   *   of an error.
   *
   * @see hook_file_references()
   */
  function delete($force = FALSE) {
    // If any module returns a value from the reference hook, the 
    // file will not be deleted from Drupal, but file_delete will
    // return a populated array that tests as TRUE.
    if (!$force && ($references = module_invoke_all('file_references', $this))) {
      return $references;
    }

    // Let other modules clean up on delete.
    module_invoke_all('file_delete', $this);
 
    // Make sure the file is deleted before removing its row from the 
    // database, so UIs can still find the file in the database.
    if (unlink($this->filepath)) {
      db_query('DELETE FROM {files} WHERE fid = %d', $this->fid);
      // remove internally used static cache entries.
      $this->reset_cache('fid::'. $this->fid);
      $this->reset_cache('filepath::'. $this->filepath);
      return TRUE;
    }
    return FALSE;
  }

  /**
   * Return the first matching file in the files table. This is a simple single
   * object loader it in combination with the static $files variable allows all
   * drupal file objects to also act as factories and share the same static cache.
   *
   * @param string key (required) database column to use in where condition.
   * @param int|string value (required) the value of the column to use in the where condition.
   * @return object|bool A Drupal file object or FALSE if a file was not found.
   * @see drupal_file::load(), drupal_file::load_path()
   */
  final function _load($column, $value) {
    // set a cache id based on key and value so we can statically cache 
    // all simple loads.
    $cid = $column . '::' . $value; 
    if (empty(self::$files[$cid])) {
      $file = db_fetch_object(db_query('SELECT f.* FROM {files} f WHERE f.%s = %d', $column, $value));
      $scheme = parse_url($file, PHP_URL_PATH);
      $class = ResourceSchemeManager::get_classname($scheme);
      $file = new $class($file);
    }
    module_invoke_all('file_load', $file);
    self::$files[$cid] = $file; 
    // Files are not cloned, because there is in fact only one.
    return self::$files[$cid];
  }
 
  /**
   * Load a file object from the database by id.
   *
   * @param int   $id     A file id. (required)
   * @return object|bool A Drupal file object or FALSE if a file was not found.
   * @see: drupal_file::load()
   */
  final function load_id($id) {
    return $this->_load('fid', $id);
  }

  /**
   * Load a file object from the database by path.
   *
   * @param string  $path   A path to a file. (required)
   * @return object|bool A Drupal file object or FALSE if a file was not found.
   * @see: drupal_file::load()
   */
  final function load_path($path) {
    return $this->_load('filepath', $path);
  }

  /**
   * Move a drupal_file.
   *
   * @param  string $destination (optional) @see file_copy.
   * @param int $replace (optional) @see file_destination
   * @return bool 
   * @see file_copy()
   */
  function move($destination, $replace = FILE_EXISTS_RENAME) {
    if (file_exists($destination)) {
      if ($replace & FILE_EXISTS_ERROR) {
        return FALSE;
      }
      if ($replace & FILE_EXISTS_RENAME) {
        $destination = $this->_exists_rename($destination); 
      }
    }
 
    if (copy($this->filepath, $destination)) {
      unlink($this->filepath);
      $orig = clone $this;
      $this->filename = basename($destination);
      $this->filepath = $result;
      if ($this->save()) {
        module_invoke_all('file_move', $this, $orig);
        return TRUE;
      }
    }
    return FALSE;
  }

  /**
   * Reset the shared static cache.
   */
  public function reset_cache($cid = FALSE) {
    // no cache id, reset the entire cache.
    if (!$cid) {
      self::$files = array();
    }
    elseif (isset(self::$files[$cid])) {
      unset(self::$files[$cid]);
    }
  }

  /**
   * Save the current state of a drupal_file in the database.
   * If the file->fid is empty a new database record will be added. 
   *
   * @return bool TRUE if save succeeded, FALSE if save failed.
   */
  function save() {
    $this->timestamp = time();
    $this->filesize = filesize($this->filepath);
  
    if (empty($this->fid)) {
      $result = drupal_write_record('files', $this);
      module_invoke_all('file_insert', $this);
    }
    else {
      $result = drupal_write_record('files', $this, 'fid');
      module_invoke_all('file_update', $this);
    }
    return $result;
  }

  /**
   * Mark a file as permanent.
   *
   * @return bool 
   */
  function set_status($bitmask = NULL) {
    if (is_null($bitmask)) {
      return $file->status;
    }
    elseif (db_query('UPDATE {files} SET status=%d', $bitmask, $this->fid)) {
      $this->status = $status;
      module_invoke_all('file_set_status', $this, $status);
      return TRUE;
    }
    return FALSE;
  }

  /**
   * Create a URL to the file.
   */
  function url() {
    return '';
  }
}

class ResourcePublic extends Resource {
  function url() { }  
  function mime() { } 
}

class ResourcePrivate extends ResourcePublic {
  function url() { }
}

class ResourceUpload extends Resource {
  public $source = '';
  public $errors;

  function save() {
    // validate if not already validated, error is validation didn't pass.
    if (!$this->validate()) {
      return FALSE;
    }
    // rename the file to its original name.
    parent::save();
  }

  function validate($validators = array()) {
    if (!isset($this->errors)) {
      // Default validation for all uploads.
      $validators['file_validate_name_length'] = array();
    
      $this->errors = array();
      foreach ($validators as $function => $args) {
        array_unshift($args, $file);
        $errors = array_merge($errors, call_user_func_array($function, $args));
      }
    }
    return !empty($this->errors);
  }

  function errors() {
    return $this->errors;
  }

  function move($dest) {
    // validate if not already validated, error is validation didn't pass.
    if (!$this->fid && !$this->save()) {
      return FALSE;
    }
    // for upload files we changed the filename in the path to a junk string...
     
  }

  /**
   * Saves a file upload to a temporary location
   *
   * The file will be added to the files table as a temporary file. Temporary
   * files are periodically cleaned. To make the file permanent file call
   * it's set_permanent() method.
   *
   * @param $source
   *   A string specifying the name of the upload field to save.
   * @param $validators
   *   An optional, associative array of callback functions used to validate the
   *   file. The keys are function names and the values arrays of callback
   *   parameters which will be passed in after the user and file objects. The
   *   functions should return an array of error messages, an empty array
   *   indicates that the file passed validation. The functions will be called in
   *   the order specified.
   * @param $destination
   *   A string containing the directory $source should be copied to. If this is
   *   not provided or is not writable, the temporary directory will be used.
   * @param $replace
   *   A boolean indicating whether an existing file of the same name in the
   *   destination directory should overwritten. A FALSE value will generate a
   *   new, unique filename in the destination directory.
   * @return
   *   An object containing the file information, or FALSE in the event of an 
   *   error.
   */

  static function save_upload($source) {
    // check and see if there were any errors.
    if (drupal_file_upload::upload_error($source)) {
      return FALSE;
    }

    // Begin building file object.
    $file = new stdClass();
    $file->source   = $source;
    $file->uid      = $user->uid;
    $file->filename = basename($_FILES['files']['name'][$source]);
    // create a tmp path to use until the file is save to a final location else where.
    // we just use a random string to defang the file for processing in tmp.
    $file->filepath = file_destination(uniqid(),  file_directory_temp(), FALSE);
    $file->filemime = $_FILES['files']['type'][$source];
    $file->filesize = $_FILES['files']['size'][$source];


    // Move uploaded files from PHP's upload_tmp_dir to Drupal's temporary 
    // directory. This overcomes open_basedir restrictions for future file
    // operations.
    if (!move_uploaded_file($_FILES['files']['tmp_name'][$source], $file->filepath)) {
      form_set_error($source, t('File upload error. Could not move uploaded file.'));
      watchdog('file api', 'Upload error. Could not move uploaded file %file to destination %destination.', array('%file' => $file->filename, '%destination' => $file->filepath));
      return FALSE;
    }
    return $file;
  }

  function upload_error($errno) {
    // If no file was uploaded there is an error. :)
    if (empty($_FILES['files']['tmp_name'][$source]) || !is_uploaded_file($_FILES['files']['tmp_name'][$source])) {
      return t('No file uploaded');
    }


    // @see http://php.net/manual/en/features.file-upload.errors.php
    switch ($_FILES['files']['error'][$source]) {
      case UPLOAD_ERR_OK:
        return FALSE;

      case UPLOAD_ERR_INI_SIZE:
      case UPLOAD_ERR_FORM_SIZE:
        return t('The file %file could not be saved, because it exceeds %maxsize, the maximum allowed size for uploads.', array('%file' => $source, '%maxsize' => format_size(file_upload_max_size())));

      case UPLOAD_ERR_PARTIAL:
      case UPLOAD_ERR_NO_FILE:
        return t('The file %file could not be saved, because the upload did not complete.', array('%file' => $source));

      case UPLOAD_ERR_NO_TMP_DIR:
        return t('The file %file could not be saved, because the PHP upload_tmp_dir does not exist.', array('%file' => $source));
          
      case UPLOAD_ERR_CANT_WRITE:
        return t('The file %file could not be saved, because the file could not be written to the disk.', array('%file' => $source));

      case UPLOAD_ERR_EXTENSION:
        return t('The file %file could not be saved, because the upload was stopped by a php extension.', array('%file' => $source));

      // Unknown error
      default:
        return t('The file %file could not be saved. An unknown error has occurred.', array('%file' => $source));
    }
  } 

  // Use static load as the entry point to keep the API interface
  // consistent.    
  function load($source) {
    if (isset(self::$files[$source])) return self::$files[$source];

    // attempt to save the upload.
    if ($file = self::save_upload($source)) {
      return new ResourcePublic($file);
    }
  }

}
  

